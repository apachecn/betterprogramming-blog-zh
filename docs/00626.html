<html>
<head>
<title>Android Fragments: Common Queries &amp; Mistakes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android碎片:常见问题和错误</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/android-fragments-common-queries-mistakes-1c42e9f6b44f?source=collection_archive---------3-----------------------#2019-06-20">https://betterprogramming.pub/android-fragments-common-queries-mistakes-1c42e9f6b44f?source=collection_archive---------3-----------------------#2019-06-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1cff" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用户面临的最常见问题的详细摘要</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3c714b489e4c35f56e33a92de5327746.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xREm7qaM09gTu00VvEEmqw.png"/></div></div></figure><p id="cb10" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Android中的<code class="fe lq lr ls lt b">Fragment</code>类用于构建动态用户界面，应该在活动中使用。使用片段的最大好处是它简化了为多种屏幕尺寸创建UI的任务。一个活动可以包含任意数量的片段。</p><p id="e807" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，这个解释让片段听起来很好很容易，对吗？没那么快，还有很多事要做。在这一部分中，我们将涵盖使用片段时的主要需求和常见错误。</p><p id="58dd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lu">注意:我假设你对片段和片段生命周期回调有基本的了解。此外，我假设您知道如何实现两个片段之间的通信。本文超越了这一点。</em></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ce3f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">障碍</h1><p id="e87a" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">这里有一些与碎片相关的障碍，你们中的一些人肯定已经面临过或者将来可能会遇到:</p><ul class=""><li id="4211" class="mz na it kw b kx ky la lb ld nb lh nc ll nd lp ne nf ng nh bi translated">fragment manager:getSupportFragmentManager和getChildFragmentManager。在使用它们时使用哪一个并避免内存泄漏</li><li id="96f8" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated">从DialogFragment、ChildFragment、BottomSheetFragment回调到父片段</li><li id="014f" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated">使用ViewPager时的片段以及何时使用FragmentStateAdapter vs FragmentPagerAdapter。</li><li id="3649" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated">何时使用FragmentTransaction添加还是替换</li><li id="18f4" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated">碎片接收器、广播和内存泄漏</li><li id="6fe0" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated">如何处理这些碎片</li><li id="919b" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated">commit()和commitAllowingStateLoss()</li><li id="f1d3" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated">片段选项菜单</li><li id="e554" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated">片段getActivity()、getView()和NullPointers异常</li><li id="9adf" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated">具有嵌套片段的onActivityResult</li><li id="0068" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated">片段和束</li><li id="bb6d" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp ne nf ng nh bi translated">后退导航</li></ul><p id="ebd9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">哇，这是一个大名单！如果你遇到了我错过的，请在评论中告诉我。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="19f2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">getSupportFragmentManager和getChildFragmentManager</h1><p id="eee5" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">FragmentManager是框架提供的类，用于创建添加、删除或替换片段的事务。</p><ul class=""><li id="3500" class="mz na it kw b kx ky la lb ld nb lh nc ll nd lp ne nf ng nh bi translated">getSupportFragmentManager<strong class="kw iu"/>与一个活动相关联。把它当作你活动的一个片段管理器。</li></ul><p id="ce1e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，无论何时在活动中使用ViewPager、BottomSheetFragment和DialogFragment，都将使用getSupportFragmentManager</p><p id="3b08" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">示例:</p><pre class="kj kk kl km gt nn lt no np aw nq bi"><span id="1c4d" class="nr md it lt b gy ns nt l nu nv">BottomDialogFragment bottomSheetDialog = BottomDialogFragment.<em class="lu">getInstance</em>();<br/>bottomSheetDialog.show(getSupportFragmentManager(), <strong class="lt iu">"Custom Bottom Sheet"</strong>);</span></pre><ul class=""><li id="1792" class="mz na it kw b kx ky la lb ld nb lh nc ll nd lp ne nf ng nh bi translated">getChildFragmentManager <strong class="kw iu"> </strong>与片段相关联。</li></ul><p id="cb82" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当你在一个片段中查看页面时，你将使用getChildFragmentManager。</p><p id="41b6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">示例:</p><pre class="kj kk kl km gt nn lt no np aw nq bi"><span id="030a" class="nr md it lt b gy ns nt l nu nv">FragmentManager cfManager=getChildFragmentManager();<br/>viewPagerAdapter = new ViewPagerAdapter(cfManager);</span></pre><p id="2254" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里是<a class="ae nw" href="https://developer.android.com/reference/android/support/v4/app/FragmentManager.html" rel="noopener ugc nofollow" target="_blank">官方链接</a>为了更好的理解。</p><p id="ba3e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当谈到人们在片段中使用ViewPager时所犯的常见错误时，他们通常会传递getSupportFragmentManager，<strong class="kw iu"> </strong>这是一个活动的片段管理器，它会导致诸如内存泄漏或ViewPager无法正确更新等问题。</p><p id="cc29" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在片段中使用getSupportFragmentManager<strong class="kw iu"/>导致的最重要的问题是内存泄漏。但是为什么会这样呢？嗯，您有一个由ViewPager使用的片段堆栈，并且所有这些片段都在活动中堆栈，因为您使用了getSupportFragmentManager。现在，如果关闭父片段，它将被关闭，但不会被销毁，因为所有子片段都是活动的，它们仍在内存中，因此会导致泄漏。它不仅会泄漏父片段，还会泄漏所有子片段，因为它们都不能从堆内存中清除。所以永远不要尝试在片段中使用getSupportFragmentManager</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="63c4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">从DialogFragment、ChildFragment、BottomSheetFragment回调到父片段</h1><p id="33aa" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">这是人们在使用BottomSheetFragment或DialogFragment或ChildFragment时面临的一个非常常见的问题。</p><p id="df74" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">示例:</p><p id="2b69" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">添加子片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="e4f5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一个示例bottomSheetFragment:</p><pre class="kj kk kl km gt nn lt no np aw nq bi"><span id="a22b" class="nr md it lt b gy ns nt l nu nv">BottomSheetDialogFragment fragment = BottomSheetDialogFragment.newInstance();<br/>fragment.show(getChildFragmentManager(), fragment.getTag());</span></pre><p id="6688" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在假设您想要从这些子片段回调到父片段。大多数人使用活动在两个片段之间创建连接，很少有人将接口侦听器作为参数传递给片段(这是一个应该避免的坏习惯)。从子片段调用getParentFragment()的最佳方式是创建一个回调。这个很简单。考虑下面的例子:</p><pre class="kj kk kl km gt nn lt no np aw nq bi"><span id="6ddb" class="nr md it lt b gy ns nt l nu nv">dialogFragment.show(ParentFragment.this.getChildFragmentManager(), "dialog_fragment");</span></pre><p id="972d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后通过在子片段中添加以下代码来设置对父片段的回调:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="8172" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就是这样。现在，您可以轻松地回调父片段。</p><p id="6408" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用相同的方法，可以创建从ViewPager内部的子片段到持有ViewPager的父片段的回调。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e4d2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用ViewPager时的片段以及何时使用FragmentStateAdapter vs FragmentPagerAdapter</h1><p id="457a" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated"><code class="fe lq lr ls lt b">FragmentPagerAdapter</code>将整个片段存储在内存中，如果在<code class="fe lq lr ls lt b">ViewPager</code>中使用大量片段，会导致内存开销增加。<code class="fe lq lr ls lt b">FragmentStatePagerAdapter</code>只存储碎片保存的实例，当它们失去焦点时销毁所有的碎片。</p><p id="43ae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以当你有很多片段时，使用FragmentStateAdapter。如果ViewPager的片段少于三个，请使用FragmentPagerAdapter。</p><p id="0432" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看看一些普遍面临的问题。</p><p id="540f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">更新ViewPager不工作:</strong></p><p id="f4cc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">记住ViewPager片段是由FragmentManager管理的，要么来自片段，要么来自活动，FragmentManager持有所有ViewPager片段的实例。</p><p id="4055" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，当人们说ViewPager没有被刷新时，它只不过是碎片的旧实例仍然被FragmentManager持有。您需要找出FragmentManger持有片段实例的原因。到底有没有漏？理想情况下，刷新ViewPager的代码如下。如果不是，那你就做错了。</p><pre class="kj kk kl km gt nn lt no np aw nq bi"><span id="3459" class="nr md it lt b gy ns nt l nu nv">List&lt;String&gt; strings = <strong class="lt iu">new </strong>ArrayList&lt;&gt;();<br/>strings.add(<strong class="lt iu">"1"</strong>);<br/>strings.add(<strong class="lt iu">"2"</strong>);<br/>strings.add(<strong class="lt iu">"3"</strong>);<br/>viewPager.setAdapter(<strong class="lt iu">new </strong>PagerFragAdapter(getSupportFragmentManager(), strings));<br/>strings.add(<strong class="lt iu">"4"</strong>);<br/>viewPager.getAdapter().notifyDataSetChanged();</span></pre><p id="c7d6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">从ViewPager访问当前片段:</strong></p><p id="c733" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这也是我们经常遇到的问题。如果遇到这种情况，要么在适配器中创建一个片段数组列表，要么尝试使用一些标记来访问片段。然而，我更喜欢另一种选择。FragmentStateAdapter和FragmentPagerAdapter都提供方法setPrimaryItem。这可用于设置当前片段，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="6d54" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我将为这个简单的ViewPager项目留下一个GitHub链接，以便每个人都能更好地理解。</p><div class="nz oa gp gr ob oc"><a href="https://github.com/amodkanthe/ViewPagerTest" rel="noopener  ugc nofollow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd iu gy z fp oh fr fs oi fu fw is bi translated">amodkanthe/ViewPagerTest</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">在GitHub上创建一个帐户，为amodkanthe/ViewPagerTest开发做贡献。</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">github.com</p></div></div><div class="ol l"><div class="om l on oo op ol oq ks oc"/></div></div></a></div></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d0ba" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">FragmentTransaction添加与替换</h1><p id="ec0a" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">在我们的活动中，我们有一个容器，里面显示了我们的片段。</p><p id="e310" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lu">添加</em>将简单地添加一个片段到容器中。假设您将FragmentA和FragmentB添加到容器中。容器将有FragmentA和FragmentB，如果容器是FrameLayout，片段将一个接一个地添加。</p><p id="097c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">替换将简单地替换容器顶部的一个片段，所以如果我调用create FragmentC并调用替换顶部的FragmentB，FragmentB将从容器中移除(除非你没有调用addToBackStack ),现在FragmentC将在顶部。</p><p id="e05e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么什么时候用哪个呢？<code class="fe lq lr ls lt b">replace</code>删除现有片段并添加新片段。这意味着当您按下back按钮时，被替换的片段将被创建，其onCreateView被调用。另一方面，<code class="fe lq lr ls lt b">add</code>保留现有片段并添加新片段，这意味着现有片段将是活动的，它们不会处于“暂停”状态。因此，当在CreateView上按下back按钮时，不会为现有片段(在添加新片段之前的片段)调用该按钮。就碎片的生命周期事件而言，在<code class="fe lq lr ls lt b">replace</code>的情况下会调用onPause、onResume、onCreateView等生命周期事件，而在<code class="fe lq lr ls lt b">add</code>的情况下不会调用。</p><p id="1539" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果不需要重新访问当前片段，并且不再需要当前片段，请使用替换片段。此外，如果你的应用程序有内存限制，考虑使用替换而不是添加。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9474" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">碎片接收器、广播和内存泄漏</h1><p id="6533" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">在片段中使用接收者时，一个常见的错误是忘记在onPause或OnDestroy中注销接收者。如果您注册一个片段来监听onCreate或OnResume中的接收器，您必须在onPause或onDestroy中取消注册它。否则会造成内存泄漏。</p><pre class="kj kk kl km gt nn lt no np aw nq bi"><span id="2a4b" class="nr md it lt b gy ns nt l nu nv">LocalBroadcastManager.getInstance(getActivity()).unregisterReceiver(mYourBroadcastReceiver);</span></pre><p id="351e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，如果有多个片段收听同一个广播接收器，请确保在onResume中注册，并在onPause中取消注册。如果您使用onCreate和onDestroy来注册和取消注册，其他片段将不会接收到广播，因为这个片段没有被销毁</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="865f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">如何处理片段底部导航和导航抽屉</h1><p id="26a4" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">当我们使用BottomBarNavigation和NavigationDrawer时，经常会看到诸如片段被重新创建或者同一个片段被多次添加之类的问题。</p><p id="e974" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，您可以使用片段事务显示和隐藏，而不是添加或替换。</p><p id="5942" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">还有一个漂亮的库叫做FragNav，它负责导航，避免了碎片的重新创建。下面我已经链接了。</p><div class="nz oa gp gr ob oc"><a href="https://github.com/ncapdevi/FragNav" rel="noopener  ugc nofollow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd iu gy z fp oh fr fs oi fu fw is bi translated">ncapdevi/FragNav</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">一个用于管理多个片段栈的Android库——ncapdevi/FragNav</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">github.com</p></div></div><div class="ol l"><div class="or l on oo op ol oq ks oc"/></div></div></a></div></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9448" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">commit()和commitAllowingStateLoss()</h1><p id="a4fd" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">如果您的活动不处于恢复状态，并且您试图提交一个片段，您的应用程序将会崩溃。为了避免这种情况，您需要检查活动或片段是否处于恢复状态<code class="fe lq lr ls lt b">isAdded()</code> / <code class="fe lq lr ls lt b">isResumed()</code></p><p id="d975" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一个解决方案是，如果您不太关心片段的状态，您可以调用commitAllowingStateLoss。<strong class="kw iu"> </strong>这确保了片段被添加或替换，尽管活动正在结束或不处于恢复状态。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="33bf" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">片段选项菜单</h1><p id="154a" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">当在片段内部使用选项菜单时，记得添加下面一行。人们经常忘记添加这个选项，并且一直想知道这个选项在工具栏的什么地方。</p><pre class="kj kk kl km gt nn lt no np aw nq bi"><span id="69fb" class="nr md it lt b gy ns nt l nu nv">@Override<br/>    public void onCreate(Bundle savedInstanceState) {<br/>        super.onCreate(savedInstanceState);<br/>        setHasOptionsMenu(true);<br/>    }</span></pre><p id="e8fa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当在片段中使用工具栏时，您可以使用代码展开菜单:</p><p id="626d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">getToolbar().inflateMenu(R.menu.toolbar_menu_gmr);</code></p><p id="8a3d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">或者，您可以覆盖createOptionsMenu，但是我更喜欢上面的方法，因为它不依赖于超类</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0805" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Fragment getActivity()，getView() NullPointers异常</h1><p id="cdd0" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">如果任何后台进程发布一个结果，而该片段不在堆栈中或处于恢复状态，则访问该片段的视图将导致NullPointer异常。因此，当您在后台操作或延迟后访问getView或getActivity时，请确保在终止时取消所有后台操作。</p><p id="f0de" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9adc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">嵌套片段onActivityResult</h1><p id="5d4e" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">是的，嵌套片段中的<code class="fe lq lr ls lt b">onActivityResult()</code>不会被调用。</p><p id="4297" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">onActivityResult(在Android支持库中)的调用顺序是</p><ol class=""><li id="4019" class="mz na it kw b kx ky la lb ld nb lh nc ll nd lp os nf ng nh bi translated"><code class="fe lq lr ls lt b">Activity.dispatchActivityResult()</code>。</li><li id="2259" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp os nf ng nh bi translated"><code class="fe lq lr ls lt b">FragmentActivity.onActivityResult()</code>。</li><li id="96e0" class="mz na it kw b kx ni la nj ld nk lh nl ll nm lp os nf ng nh bi translated"><code class="fe lq lr ls lt b">Fragment.onActivityResult()</code>。</li></ol><p id="8544" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您必须在父片段或活动中使用<code class="fe lq lr ls lt b">onActivityResult()</code>,并将结果传递给嵌套片段，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5384" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">片段和束</h1><p id="60be" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">无论何时向片段传递参数，都要确保使用Bundle而不是构造函数。</p><p id="9da6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Android文档声明:</p><p id="9729" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lu">每个片段必须有一个空的构造函数，这样在恢复其活动状态时就可以实例化。强烈建议子类不要有其他带参数的构造函数，因为这些构造函数在片段被重新实例化时不会被调用；相反，参数可以由调用者用setArguments(Bundle)提供，稍后由片段用getArguments()检索。</em></p><p id="d3c2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是为什么最好使用bundle来设置片段的参数，当片段被重新实例化时，系统更容易恢复它的值。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8a03" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">后退导航</h1><p id="9cb1" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">您应该确保在详细屏幕上按下<em class="lu">返回</em>按钮会将用户返回到主屏幕。为此，在提交事务之前调用<code class="fe lq lr ls lt b"><a class="ae nw" href="https://developer.android.com/reference/android/app/FragmentTransaction.html#addToBackStack(java.lang.String)" rel="noopener ugc nofollow" target="_blank">addToBackStack()</a></code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="a17e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当后台栈上有<code class="fe lq lr ls lt b"><a class="ae nw" href="https://developer.android.com/reference/android/app/FragmentTransaction.html" rel="noopener ugc nofollow" target="_blank">FragmentTransaction</a></code>个对象，用户按下<em class="lu"> Back </em>按钮时，<code class="fe lq lr ls lt b"><a class="ae nw" href="https://developer.android.com/reference/android/app/FragmentManager.html" rel="noopener ugc nofollow" target="_blank">FragmentManager</a></code>从后台栈弹出最近的事务，并执行相反的操作(比如如果事务添加了一个片段，则删除该片段)。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="159a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="ac1c" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">片段一开始看起来很简单，但是还有更多。在使用片段时，你需要注意很多事情，比如内存、导航、回调和捆绑。我希望本文涵盖了最常见的问题和最常犯的错误。</p></div></div>    
</body>
</html>