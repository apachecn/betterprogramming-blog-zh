# Synthwave åœºæ™¯â€”â€”æˆ‘æœ€é…·çš„ Three.js é¡¹ç›®

> åŸæ–‡ï¼š<https://betterprogramming.pub/synthwave-scene-my-coolest-three-js-project-yet-6359c38dfd08>

## æˆ‘çš„ä»£ç çš„è¯¦ç»†æ¼”ç»ƒ

![](img/b54205eab561a3878b99f4bb7aa182c0.png)

å¤§çº¦ä¸¤å¹´å‰ï¼Œæˆ‘å®Œå…¨è¿·ä¸Šäº† YouTube ä¸Šçš„ Retrowave/Synthwave éŸ³ä¹ã€‚æˆ‘çœŸçš„å¾ˆå–œæ¬¢éŸ³ä¹å’Œè§†è§‰çš„å¤å¤æœªæ¥ä¸»ä¹‰ç¾å­¦â€”â€”ä¸€ä¸ªå‘å‰ç§»åŠ¨çš„è§†è§’ï¼Œå±•ç¤ºäº†ä¸€ä¸ªè¶…çº§é…·çš„æ°¸ä¸ç»“æŸçš„éœ“è™¹ç½‘æ ¼ï¼Œå¤•é˜³å°±åœ¨åœ°å¹³çº¿ä¸Šã€‚ä»é‚£ä»¥åï¼Œæˆ‘ä¸€ç›´æƒ³ç”¨ Three.js é‡æ–°åˆ›å»ºä¸€ä¸ªâ€œSynthwave åœºæ™¯â€

æˆ‘è®°å¾—å»å¹´æˆ‘ç¬¬ä¸€æ¬¡å°è¯•ï¼Œä½†æˆ‘åœ¨æŸä¸ªæ—¶å€™å¡ä½äº†ï¼Œå¾ˆå¿«å°±æ„Ÿåˆ°æ²®ä¸§ï¼Œæœ€åæ”¾å¼ƒäº†ã€‚è€å®è¯´ï¼Œé‡ç°åœºæ™¯ä¸æ˜¯ä¸€ä»¶ç®€å•çš„å·¥ä½œï¼Œå¯¹åˆå­¦è€…æ¥è¯´æ›´æ˜¯å¦‚æ­¤ã€‚æˆ‘ä¸ºè‡ªå·±æœ€ç»ˆåˆ›é€ äº†ä¸€ä¸ªåƒæ ·çš„ Synthwave åœºæ™¯æ„Ÿåˆ°éå¸¸è‡ªè±ªã€‚ç°åœ¨ï¼Œæˆ‘å°†å¸¦ä½ ä¸€æ­¥ä¸€æ­¥åœ°å®Œæˆåˆ›å»ºç›¸åŒåœºæ™¯çš„è¿‡ç¨‹ã€‚

å…ˆè¯´ç»†åˆ†ã€‚

# æ•™ç¨‹åˆ†è§£

1.  ç°åœºæ¼”ç¤º
2.  æ„å»ºåœ°å½¢çš„æ–¹æ³•
3.  é¡¹ç›®çš„ä»£ç ç»“æ„
4.  è®¾ç½®åœºæ™¯ç¯å¢ƒ
5.  ä¸ºåœ°å½¢â›°è®¾ç½®å¹³é¢å‡ ä½•ä½“
6.  åœ¨åœ°å½¢ä¸Šåˆ›å»ºäº®/éœ“è™¹ç½‘æ ¼çº¿
7.  åˆ›é€ ä¸€ä¸ªæ²¡æœ‰å°½å¤´çš„åœ°å½¢çš„å¹»è§‰
8.  æ·»åŠ è½æ—¥â˜€å¹¶åˆ¶ä½œåŠ¨ç”»
9.  æ·»åŠ  GUI æ§ä»¶ä»¥åœ¨è¿è¡Œæ—¶è°ƒæ•´å‚æ•°
10.  ç”¨ Bloom æ•ˆæœå¯¹åœºæ™¯è¿›è¡ŒåæœŸå¤„ç†ï¼Œè®©å®ƒçœ‹èµ·æ¥æ›´é…·ï¼

# 1.ç°åœºæ¼”ç¤º

åƒå¾€å¸¸ä¸€æ ·ï¼Œå…ˆçœ‹çœ‹ä½ è¦å»ºç«‹ä»€ä¹ˆï¼è¿™ä¸ªæ¼”ç¤ºæ˜¯æ‰˜ç®¡åœ¨æˆ‘çš„ä»£ç æ²™ç›’å¸æˆ·ã€‚åœ¨æ›´å¤§çš„çª—å£é‡Œçœ‹èµ·æ¥æ›´å¥½ï¼Œä¸é‚£ä¹ˆç¬¨é‡ã€‚

å¾ˆé…·çš„åœºæ™¯å§ï¼Ÿ

å¦‚æœä½ æƒ³çœ‹å®Œæ•´çš„ä»£ç ï¼Œè¯·æŸ¥çœ‹ https://github.com/franky-adl/threejs-synthwave-scene çš„ã€‚

# 2.æ„å»ºåœ°å½¢çš„æ–¹æ³•

è¿™ä¸€èŠ‚è§£é‡Šäº†å¦‚ä½•å¤„ç†åœ¨åˆ¶ä½œåœ°å½¢å‡ ä½•å›¾å½¢æ—¶é‡åˆ°çš„é—®é¢˜ï¼Œè¿™çœŸçš„æœ‰åŠ©äºä½ ç†è§£æˆ‘åœ¨å¹•åçš„æ€è€ƒè¿‡ç¨‹ã€‚è¿™ä¼šå˜å¾—æœ‰ç‚¹é•¿ï¼Œæ‰€ä»¥å¦‚æœä½ æƒ³é©¬ä¸Šè¿›å…¥ä»£ç ï¼Œè·³åˆ°ä¸‹ä¸€èŠ‚ã€‚

åˆ¶ä½œ synthwave åœºæ™¯è¦å…‹æœçš„ç¬¬ä¸€ä¸ªéšœç¢æ˜¯ç”Ÿæˆåœ°å½¢ã€‚æˆ‘ä»¬å°†åˆ¶ä½œä¸€ä¸ªä¸­é—´å¹³å¦çš„åœ°å½¢ä½œä¸ºé“è·¯ï¼Œä¸¤è¾¹å´å²–ä¸å¹³çš„åœ°å½¢ä½œä¸ºå±±è„‰ã€‚æœ‰ä¸åŒçš„æ–¹æ³•ç”Ÿæˆåœ°å½¢ï¼›æœ‰äº›åœ¨ä½ è„‘æµ·ä¸­çœ‹èµ·æ¥å¾ˆå®¹æ˜“ï¼Œä½†å½“ä½ å°è¯•ç¼–ç æ—¶å´å¾ˆéš¾ã€‚ä¸ºäº†æ›´æ·±å…¥åœ°äº†è§£åœ°å½¢é—®é¢˜ï¼Œå®é™…ä¸Šæœ‰ä¸‰ä¸ªä¸»è¦é—®é¢˜:

A.æˆ‘ä»¬åº”è¯¥ä½¿ç”¨ä»€ä¹ˆæ ·çš„å‡ ä½•å›¾å½¢ï¼Ÿ
B .å¦‚ä½•ä½¿åœ°å½¢ä¸­é—´å¹³å¦è€Œä¸¤è¾¹å‡¹å‡¸ä¸å¹³ï¼Ÿ
C .å¦‚ä½•åˆ¶ä½œåœ°å½¢åŠ¨ç”»æ¥ä¼ªé€ ä¸€ä¸ªæ— å°½çš„é“è·¯æ•ˆæœï¼Ÿ

è®©æˆ‘ä»¬ä¸€ä¸ªä¸€ä¸ªæ¥ã€‚

## **A .æˆ‘ä»¬åº”è¯¥ä½¿ç”¨ä»€ä¹ˆæ ·çš„å‡ ä½•å›¾å½¢ï¼Ÿ**

ä¹ä¸€çœ‹ï¼Œä½ å¯èƒ½è®¤ä¸º`PlaneGeometry`æ˜¯æ˜¾è€Œæ˜“è§çš„é€‰æ‹©ï¼›æ˜¯çš„ï¼Œä½†ä¹Ÿæœ‰ä¸€äº›æ›²æŠ˜ã€‚æœ‰å¾ˆé‡è¦çš„ä¸€ç‚¹è¦è®°ä½:éœ“è™¹ç¯çº¿å¿…é¡»åŒ¹é…è¿™ä¸ªå¹³é¢å‡ ä½•çš„çº¿æ¡†ï¼›æ¯”æ–¹è¯´ï¼Œå¦‚æœéœ“è™¹ç¯çº¿ä¸æ²¿ç€ä½ çš„`PlaneGeometry`ç½‘æ ¼ä¸­çš„å¯¹è§’çº¿ï¼Œä½ ä¼šçœ‹åˆ°ç›¸é‚»çš„ä¸‰è§’å½¢é¢çš„é˜´å½±åœ¨å¯¹è§’çº¿ä¸Šå˜åŒ–ï¼Œä½†æ˜¯å¦‚æœæ²¡æœ‰ä¸€æ¡çº¿æ¥åˆ‡æ–­é˜´å½±çš„å˜åŒ–ï¼Œè§†è§‰æ•ˆæœä¼šçœ‹èµ·æ¥å¾ˆå¥‡æ€ªã€‚å› æ­¤ï¼Œå¦‚æœä½ ä½¿ç”¨é¦™è‰`PlaneGeometry`ä½œä¸ºåœ°å½¢çš„åŸºç¡€å‡ ä½•å›¾å½¢ï¼Œä½ çš„éœ“è™¹çº¿ä¹Ÿéœ€è¦è¿½è¸ªé™¤å‚ç›´å’Œæ°´å¹³ç½‘æ ¼çº¿ä¹‹å¤–çš„æ‰€æœ‰å¯¹è§’çº¿ï¼Œç¼ºç‚¹æ˜¯ä½¿ä¸­å¤®é€šé“çœ‹èµ·æ¥ä¸å¯¹ç§°ã€‚

![](img/d8862c59040317819b831e4a31c2b159.png)

æ™®é€šå¹³é¢å‡ ä½•çš„çº¿æ¡†

å¦‚æœæˆ‘ä»¬æƒ³é¿å…å¯¹è§’çº¿é—®é¢˜ï¼Œæœ‰ 3 ä¸ªé€‰æ‹©ã€‚

1.  å°†æ•´ä¸ª`PlaneGeometry`æ—‹è½¬ 45 åº¦ï¼
2.  åˆ¶ä½œä¸€ä¸ªè‡ªå®šä¹‰çš„`BufferGeometry`ï¼Œå®ƒæ˜¯æ—‹è½¬æ–¹å—çš„é•¶åµŒã€‚
3.  åœ¨ y æ–¹å‘å‰ªåˆ‡`PlaneGeometry`ï¼Œç›´åˆ°ä½ æœ‰ä¸€ä¸ªå¯¹ç§°ä¸‰è§’å½¢çš„é•¶åµŒï¼

![](img/ee849bd01970fcd022eb6a1b3f926676.png)![](img/3fc0c3b13481cec208b7e73c03e8a9df.png)

å·¦:é€‰é¡¹ 1 å°†å¹³é¢æ—‹è½¬ 45 åº¦ï¼Œå³:é€‰é¡¹ 2 è¿›è¡Œè‡ªå®šä¹‰ç¼“å†²æµ‹é‡

![](img/2c124c2636fffef5521c29aff46b8bfe.png)

é€‰é¡¹ 3:ä½¿ç”¨`matrix.makeShear()`å‰ªåˆ‡å¹³é¢ï¼Œxy è®¾ç½®ä¸º-0.5

ä½ å¯èƒ½ä¼šè¯´ï¼Œå˜¿ï¼Œæœ‰é€‰é¡¹ 4ï¼Œè¿™æ˜¯ç®€å•åœ°ä½¿ç”¨ä¸€ä¸ªæ­£æ–¹å½¢ç½‘æ ¼ï¼é—æ†¾çš„æ˜¯ï¼Œè¿™ä¸æ˜¯ä¸€ä¸ªå¯è¡Œçš„é€‰æ‹©ï¼Œå› ä¸ºä¸‰è§’å½¢æœ€ç»ˆæ˜¯ Three.js çš„åŸºæœ¬æ„å»ºå—ï¼›æ®æˆ‘æ‰€çŸ¥ï¼Œä¸å¯èƒ½ç”¨çº¯æ­£æ–¹å½¢æ¥å †å ç½‘æ ¼ã€‚

å› æ­¤ï¼Œè®©æˆ‘ä»¬è€ƒè™‘ 3 ä¸ªé€‰é¡¹ã€‚è¯·è®°ä½ï¼Œæˆ‘ä»¬éœ€è¦åœ¨åœ°å½¢ä¸­é“ºè®¾ä¸€æ¡å¾ˆé•¿çš„é“è·¯ï¼Œå› æ­¤æˆ‘ä»¬å¯èƒ½éœ€è¦å¤åˆ¶å’Œè¿æ¥é£æœºï¼Œä»¥ä¾¿ä½¿å®ƒæ›´é•¿ã€‚

*   å¯¹äºé€‰é¡¹ 1ï¼Œä»å¤´åˆ°è„šè¿æ¥å¤šä¸ªæ—‹è½¬çš„å¹³é¢ä¼šäº§ç”Ÿä¸€ä¸ªæ˜æ˜¾çš„é—®é¢˜:å®ƒä»¬ä¹‹é—´ä¼šæœ‰å¾ˆå¤§çš„ç©ºç™½ç©ºé—´ã€‚å°†ä¸€ä¸ªæŒ‡å‘å‰æ–¹çš„è±å½¢é•¶åµŒæˆä¸€æ¡é“è·¯æ˜¯éå¸¸ç—›è‹¦å’Œä½æ•ˆçš„ã€‚
*   å¯¹äºé€‰é¡¹ 2ï¼Œè‡ªå®šä¹‰å‡ ä½•å›¾å½¢çœ‹èµ·æ¥ä¸é”™ï¼Œä½†æ˜¯å¼€é”€å¤ªé«˜ï¼›ä½ å°†ä¸å¾—ä¸è‡ªå·±è®¡ç®—å’Œè®¾ç½®é¡¶ç‚¹çš„ä½ç½®ï¼Œå¹¶ä¸”ç²¾ç¡®åœ°è¿æ¥å¹³é¢æ›´åŠ å¤æ‚ã€‚
*   å¯¹äºé€‰é¡¹ 3ï¼Œåªéœ€è¦ 2-3 è¡Œä»£ç å°±å¯ä»¥å‰ªåˆ‡å®ƒï¼Œç›´åˆ°ä¸‰è§’å½¢å¯¹å¯¹ç§°ã€‚å¼€é”€å¾ˆå°ã€‚è™½ç„¶æ•´ä¸ªå¹³é¢è¢«å¯¹è§’æ‹‰ä¼¸ï¼Œä½†ä»ç„¶å¾ˆå®¹æ˜“å°†å¹³é¢ç›¸ä¹˜å¹¶è¿æ¥èµ·æ¥ï¼Œå¦‚æœæˆ‘ä»¬æ­£ç¡®è®¾ç½®ç›¸æœºå’ŒåŠ¨ç”»å¾ªç¯ï¼Œè§‚ä¼—ä¸ä¼šæ³¨æ„åˆ°å‰ªåˆ‡ã€‚

é€‰é¡¹ 3 æ˜¯èµ¢å®¶ğŸ‘‘ï¼

## **B .å¦‚ä½•è®©åœ°å½¢ä¸­é—´å¹³å¦è€Œä¸¤è¾¹å‡¹å‡¸ä¸å¹³ï¼Ÿ**

æˆ‘ä»¬é¦–å…ˆéœ€è¦ä¸€å¼ é«˜åº¦å›¾ã€‚ä¸ç®¡ä½ æ˜¯ç”¨æ‰‹å·¥è¿˜æ˜¯ç”¨ä¸€äº›ç”Ÿæˆä»£ç æ¥åšï¼Œéƒ½åº”è¯¥æ˜¯é»‘ç™½å›¾åƒï¼Œç™½è‰²ä»£è¡¨æœ€é«˜ï¼Œé»‘è‰²ä»£è¡¨æœ€ä½ã€‚æˆ‘åœ¨ Affinity Designer ä¸­ä½¿ç”¨å¾„å‘æ¸å˜å’Œçº¹ç†ç¬”åˆ·ç”Ÿæˆäº†æˆ‘çš„ã€‚æ˜¾ç„¶ï¼Œæˆ‘ä»¬éœ€è¦ä¿æŒä¸­å¤®å‚ç›´çŸ©å½¢åŒºåŸŸä¸ºé»‘è‰²ï¼Œä»¥ä¾¿å°†å…¶ä½œä¸ºé“è·¯é“ºè®¾ã€‚

![](img/dc96731e45bc8eafe0ba498c798ee09a.png)

æˆ‘åœ¨åˆæˆæ³¢åœºæ™¯ä¸­ä½¿ç”¨çš„é«˜åº¦å›¾

ä¸‹ä¸€ä¸ªé—®é¢˜æ˜¯ç”¨è¿™ä¸ªé«˜åº¦å›¾ä¸­çš„é«˜åº¦æ•°æ®æ¥æ¸²æŸ“æˆ‘ä»¬çš„å¹³é¢å‡ ä½•ã€‚æˆ‘å°è¯•çš„ç¬¬ä¸€ä»¶äº‹æ˜¯ä½¿ç”¨`TextureLoader`åŠ è½½é«˜åº¦å›¾å›¾åƒï¼Œç„¶åå°†çº¹ç†åˆ†é…ç»™`MeshStandardMaterial`çš„`displacementMap`å±æ€§ã€‚ä½†æ˜¯è¿™ç§æ–¹æ³•ä¸é€‚ç”¨äºä»¥ååˆ›å»ºçš„éœ“è™¹çº¿(æˆ‘å°†åœ¨éœ“è™¹çº¿éƒ¨åˆ†è§£é‡ŠåŸå› ),å› ä¸º`displacementMap`å±æ€§åªåœ¨è¿è¡Œæ—¶æ›´æ–°`vertexShader`ç¨‹åºä¸­çš„é¡¶ç‚¹ä½ç½®ï¼Œæˆ‘ä»¬çš„ä¸» js ç¨‹åºä¸­çš„å¹³é¢å‡ ä½•å¯¹è±¡çš„ positions æ•°ç»„ä¸å—å½±å“ã€‚

å› æ­¤ï¼Œæˆ‘ä¸å¾—ä¸æ‰‹åŠ¨ä»ä½ç§»è´´å›¾ä¸­æå–ç°åº¦å€¼ï¼Œç¼©æ”¾å®ƒï¼Œå¹¶å°†å…¶å€¼ç›´æ¥åˆ†é…ç»™æˆ‘ä»¬çš„å‡ ä½•å¯¹è±¡çš„æ¯ä¸ªé¡¶ç‚¹çš„ z ä½ç½®å€¼ã€‚æˆ‘å‘ç°æˆ‘ä»¬ç”šè‡³ä¸éœ€è¦æ‰‹åŠ¨è®¡ç®—æ³•çº¿ï¼Œç¯å…‰åªæ˜¯ä»¥æŸç§æ–¹å¼å·¥ä½œï¼

## å¦‚ä½•åˆ¶ä½œåœ°å½¢åŠ¨ç”»æ¥æ¨¡æ‹Ÿä¸€ä¸ªæ— å°½çš„é“è·¯æ•ˆæœï¼Ÿ

è¿™ä¸ªé—®é¢˜å­˜åœ¨äºå¾ˆå¤šéœ€è¦æŸç§æ— å°½ä¹‹è·¯çš„æ¸¸æˆ/åŠ¨ç”»ä¸­ã€‚æˆ‘æ•¢è‚¯å®šï¼Œè¿™æ˜¯è§£å†³äº†å¾ˆå¤šæ¬¡ï¼Œååå¤å¤ã€‚æ˜¯çš„ï¼Œè¿™ä¸ªé—®é¢˜æœ¬èº«å¾ˆå®¹æ˜“è§£å†³ï¼Œä½†åœ¨æˆ‘ä»¬çš„æƒ…å†µä¸‹ï¼Œæœ‰ä¸€ä¸ªé¢å¤–çš„å¤æ‚æ€§(å°†åœ¨ä¸‹ä¸€æ®µè§£é‡Š)ã€‚å¤§å±€ä¾æ—§ï¼›å‡è®¾æˆ‘ä»¬æœ‰å¤šä¸ªå¹³é¢å®ä¾‹è¿æ¥åœ¨ä¸€èµ·å½¢æˆæˆ‘ä»¬çš„é“è·¯ï¼Œæˆ‘ä»¬è®©å®ƒä»¬åƒç«è½¦ä¸€æ ·å‘ç›¸æœºåŠ é€Ÿï¼Œè¿™æ ·ä»ç›¸æœºçš„è§’åº¦çœ‹ï¼Œæˆ‘ä»¬å°±åƒæ˜¯åœ¨å‰è¿›ã€‚ä¸€æ—¦ç«è½¦çš„è½¦å¤´åœ¨æˆ‘ä»¬çš„ç›¸æœºåé¢ï¼Œæˆ‘ä»¬å°±æŠŠå®ƒçš„ä½ç½®è°ƒå›åˆ°ç«è½¦çš„å°¾éƒ¨ï¼Œè¿™å°±æ˜¯å¦‚ä½•è®©æˆ‘ä»¬çš„è·¯çœ‹èµ·æ¥æ²¡æœ‰å°½å¤´ã€‚

é¢å¤–çš„é—®é¢˜æ˜¯ï¼Œæˆ‘ä»¬å¦‚ä½•ç¡®ä¿å¹³é¢å®ä¾‹åœ¨å®ƒä»¬çš„è¿æ¥å¤„å®Œç¾åœ°ç»“åˆåœ¨ä¸€èµ·ï¼Œæ²¡æœ‰é—´éš™ã€‚æƒ³è±¡ä¸€ä¸‹ï¼Œå¯¹æ‰€æœ‰å¹³é¢å®ä¾‹ä½¿ç”¨ç›¸åŒçš„`heightmap`ï¼Œé«˜åº¦å›¾çš„é¡¶è¡Œåƒç´ å¾ˆå¯èƒ½ä¸åº•è¡Œåƒç´ ä¸åŒ¹é…ï¼Œè‡ªç„¶ï¼Œæ‚¨ä¼šçœ‹åˆ°è¿™æ ·çš„é—´éš™:

![](img/5143cb4f158503eaed1cd269dcb68468.png)

å¹³é¢å®ä¾‹ä¹‹é—´çš„é—´éš™ï¼Œå¦‚æœå®ƒä»¬æ²¡æœ‰å®Œå…¨ä»ä¸Šåˆ°ä¸‹ç¼åˆ

è§£å†³æ–¹æ¡ˆå…¶å®å¾ˆç®€å•ã€‚æ‚¨å¯ä»¥ç¼–è¾‘æ‚¨çš„é«˜åº¦å›¾å›¾åƒï¼Œå¤åˆ¶é¡¶è¡Œåƒç´ å¹¶å°†å…¶ç²˜è´´åœ¨åº•è¡Œåƒç´ çš„é¡¶éƒ¨ã€‚é‚£è¡Œå¾—é€šã€‚

ä½†æˆ‘æ›´å–œæ¬¢ç¼–ç¨‹çš„æ–¹å¼ï¼Œå› ä¸ºå¦‚æœä½ æƒ³åœ¨é«˜åº¦å›¾å›¾åƒä¹‹é—´åˆ‡æ¢ï¼Œç¨‹åºä¼šè‡ªåŠ¨ä¸ºä½ åšå®Œç¾çš„ç¼åˆï¼Œè¿™æ ·ä½ å°±ä¸å¿…æ¯æ¬¡æƒ³å°è¯•æ–°çš„`heightmap`æ—¶éƒ½äº²è‡ªåšç¼åˆå·¥ä½œã€‚

# 3.é¡¹ç›®çš„ä»£ç ç»“æ„

æˆ‘ä»æˆ‘çš„è‡ªå®šä¹‰æ¨¡æ¿å¼€å§‹è¿™ä¸ªé¡¹ç›®ï¼Œåœ¨ https://github.com/franky-adl/threejs-starter-template å…¬å¼€æ‰˜ç®¡ã€‚ç¼–å†™æœ¬æ•™ç¨‹æ—¶ï¼Œå‡è®¾æ‚¨ä½¿ç”¨æ­¤åˆå­¦è€…æ¨¡æ¿å¼€å§‹é¡¹ç›®ã€‚

å½“ç„¶ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨ä»»ä½•æ‚¨å–œæ¬¢çš„æ ·æ¿æ–‡ä»¶æˆ–è®¾ç½®ï¼Œç„¶åæ‚¨å¿…é¡»åšä¸€äº›å°çš„ä»£ç ç¿»è¯‘ï¼Œä½¿æˆ‘çš„ä»£ç ä¸ºæ‚¨çš„è®¾ç½®å·¥ä½œã€‚å…³äºè¿™ä¸ªåˆå­¦è€…æ¨¡æ¿å¦‚ä½•å·¥ä½œçš„æ›´å¤šç»†èŠ‚ï¼Œä½ å¯ä»¥åœ¨è¿™é‡Œé˜…è¯»æˆ‘ä»¥å‰çš„æ–‡ç« ã€‚

ç°åœ¨ï¼Œè®©æˆ‘ç®€å•ä»‹ç»ä¸€ä¸‹ä»£ç çš„ç»“æ„ã€‚

é¡¹ç›®æ–‡ä»¶å±‚æ¬¡ç»“æ„:

```
.
â”œâ”€â”€ src
â”‚   â””â”€â”€ assets
â”‚       â”œâ”€â”€ heightmap.png
â”‚       â””â”€â”€ Starfield.png
â”‚   â”œâ”€â”€ common-utils.js
â”‚   â”œâ”€â”€ core-utils.js
â”‚   â”œâ”€â”€ functions.js
â”‚   â”œâ”€â”€ index.html
â”‚   â””â”€â”€ index.js
â”œâ”€â”€ .gitignore
â”œâ”€â”€ package-lock.json
â””â”€â”€ package.json
```

æˆ‘ä»¬æ‰€æœ‰çš„ä»£ç å’Œå›¾ç‰‡åŸºæœ¬ä¸Šéƒ½åœ¨`src`æ–‡ä»¶å¤¹é‡Œã€‚åœ¨`package.json`ä¸­ï¼Œæˆ‘ä»¬åªæœ‰ 3 ä¸ªä¾èµ–é¡¹:

*   `three@0.145.0`:three . js åº“
*   `dat.gui@0.7.9`:GUI æ§ä»¶åº“
*   `parcel@2.7.0`:æ†æ‰æœºå·¥å…·

åœ¨`src`ä¸­ï¼Œå°†æ‰€æœ‰çš„çº¹ç†/å›¾åƒä¿å­˜åœ¨`assets`å­æ–‡ä»¶å¤¹ä¸‹ã€‚

åŒ…å«å¤§éƒ¨åˆ†åœºæ™¯æ„å»ºä»£ç çš„æ–‡ä»¶æ˜¯`index.js`æ–‡ä»¶ã€‚

`core-utils.js`åŒ…å«ä¸€äº›æ–¹ä¾¿çš„æ–¹æ³•ï¼Œç”¨äºè®¾ç½®å¤§å¤šæ•° Three.js é¡¹ç›®ä¸­éœ€è¦çš„å…¬å…±å¯¹è±¡(å³ç›¸æœºã€æ¸²æŸ“å™¨ã€åˆæˆå™¨ã€çª—å£å¤§å°è°ƒæ•´ç›‘å¬å™¨ã€é¼ æ ‡`onmove`ç›‘å¬å™¨ã€åŠ¨ç”»å¾ªç¯)ã€‚

`common-utils.js`æœ‰ä¸€äº›æ›´æ–¹ä¾¿çš„æ–¹æ³•ï¼Œæˆ‘è‡ªå·±å‘ç°è¿™äº›æ–¹æ³•åœ¨ Three.js é¡¹ç›®ä¸­å¾ˆæœ‰ç”¨(ä¾‹å¦‚ï¼Œæ”¯æŒ async/await çš„å›¾åƒåŠ è½½å‡½æ•°ï¼Œåå…­è¿›åˆ¶åˆ° rgb çš„è½¬æ¢å™¨ç­‰ç­‰)ã€‚

`functions.js`åŒ…å«äº†åœ¨è¿™ä¸ªé¡¹ç›®ä¸­ä½¿ç”¨çš„å‡½æ•°ï¼Œè¿™äº›å‡½æ•°æœ‰åŠ©äºä»ä¸» js æ–‡ä»¶ä¸­å–å‡ºéƒ¨åˆ†ä»£ç ï¼Œä½¿å…¶å¯è¯»æ€§æ›´å¥½ï¼Œä½“ç§¯æ›´å°ã€‚

`index.html`æ˜¯ package bundler çš„å…¥å£ç‚¹ï¼Œå®ƒæœ‰ä¸€ä¸ªè¯·æ±‚`index.js`æ–‡ä»¶çš„è„šæœ¬æ ‡ç­¾ã€‚

# 4.è®¾ç½®åœºæ™¯ç¯å¢ƒ

è®©æˆ‘ä»¬å‡è®¾æˆ‘ä»¬ä½¿ç”¨æˆ‘çš„`[threejs-starter-template](https://github.com/franky-adl/threejs-starter-template)`å¼€å§‹è¿™ä¸ªé¡¹ç›®ã€‚è¿è¡Œä»¥ä¸‹å‘½ä»¤å°†æ‰“å¼€ä¸€ä¸ªé€‰é¡¹å¡ï¼Œæ˜¾ç¤ºä¸€äº›ç¯ç®±åé¢çš„æ—‹è½¬åœ†ç¯ã€‚

```
git clone https://github.com/franky-adl/threejs-starter-template
cd threejs-starter-template
npm i
npm run start
```

æ ¹æ®è‡ªå·±çš„å–œå¥½ï¼Œåœ¨ä¸åŒçš„åœ°æ–¹é‡å‘½åé¡¹ç›®åç§°`threejs-starter-template`ã€‚åœºæ™¯ä¸­çš„ç‰©ä½“åªæ˜¯ä¸ºäº†æ¼”ç¤ºï¼Œæˆ‘ä»¬éœ€è¦ç§»é™¤å®ƒä»¬ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥é‡æ–°å¼€å§‹ã€‚

è¿›è¡Œæ¸…ç†ï¼Œå¹¶ç”¨ä»¥ä¸‹ä»£ç æ›¿æ¢`index.js`çš„å†…å®¹:

```
// ThreeJS and Third-party deps
import * as THREE from "three"
import * as dat from 'dat.gui'
import Stats from "three/examples/jsm/libs/stats.module"
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls"

// Core boilerplate code deps
import { createCamera, createComposer, createRenderer, runApp } from "./core-utils"

global.THREE = THREE

/**************************************************
 * 0\. Tweakable parameters for the scene
 *************************************************/
const params = {
  // general scene params
}

/**************************************************
 * 1\. Initialize core threejs components
 *************************************************/
// Create the scene
let scene = new THREE.Scene()

// Create the renderer via 'createRenderer',
// 1st param receives additional WebGLRenderer properties
// 2nd param receives a custom callback to further configure the renderer
let renderer = createRenderer({ antialias: true })

// Create the camera
// Pass in fov, near, far and camera position respectively
let camera = createCamera(45, 1, 1000, { x: 0, y: 5, z: -15 })

// The RenderPass is already created in 'createComposer'
let composer = createComposer(renderer, scene, camera, (comp) => {
})

/**************************************************
 * 2\. Build your scene in this threejs app
 * This app object needs to consist of at least the async initScene() function (it is async so the animate function can wait for initScene() to finish before being called)
 * initScene() is called after a basic threejs environment has been set up, you can add objects/lighting to you scene in initScene()
 * if your app needs to animate things(i.e. not static), include a updateScene(interval, elapsed) function in the app as well
 *************************************************/
let app = {
  async initScene() {
    // OrbitControls
    this.controls = new OrbitControls(camera, renderer.domElement)
    this.controls.enableDamping = true

    // GUI controls
    const gui = new dat.GUI()

    // Stats - show fps
    this.stats1 = new Stats()
    this.stats1.showPanel(0) // Panel 0 = fps
    this.stats1.domElement.style.cssText = "position:absolute;top:0px;left:0px;"
    // this.container is the parent DOM element of the threejs canvas element
    this.container.appendChild(this.stats1.domElement)
  },
  // @param {number} interval - time elapsed between 2 frames
  // @param {number} elapsed - total time elapsed since app start
  updateScene(interval, elapsed) {
    this.controls.update()
    this.stats1.update()
  }
}

/**************************************************
 * 3\. Run the app
 * 'runApp' will do most of the boilerplate setup code for you:
 * e.g. HTML container, window resize listener, mouse move/touch listener for shader uniforms, THREE.Clock() for animation
 * Executing this line puts everything together and runs the app
 * ps. if you don't use custom shaders, pass undefined to the 'uniforms'(2nd-last) param
 * ps. if you don't use post-processing, pass undefined to the 'composer'(last) param
 *************************************************/
runApp(app, scene, renderer, camera, true, undefined, composer)
```

ç„¶åï¼Œä»èµ„äº§æ–‡ä»¶å¤¹ä¸­ç§»é™¤`checker_tile.png`ã€‚

ç°åœ¨è¿è¡Œ`npm run start`åº”è¯¥ä¼šç»™ä½ ä¸€ä¸ªé»‘å±ï¼Œåœ¨å·¦ä¸Šè§’åªæœ‰ fps è®¡æ•°å™¨ã€‚ä»ç°åœ¨å¼€å§‹ä¿å­˜å¯¹æ–‡ä»¶çš„ä»£ç æ›´æ”¹å°†è§¦å‘ packet bundler è‡ªåŠ¨é‡æ–°æ„å»ºï¼Œå¹¶ä¸”æ‚¨çš„ Three.js æµè§ˆå™¨é€‰é¡¹å¡å°†è‡ªåŠ¨åˆ·æ–°ã€‚

```
% npm run start

> threejs-synthwave-scene@1.0.0 start
> parcel src/index.html --open

Server running at http://localhost:1234
âœ¨ Built in 1.21s
```

è®©æˆ‘ä»¬å…ˆæ”¾ä¸€å¼ èƒŒæ™¯å›¾ç‰‡å§ï¼

å°† [my synthwave repo](https://github.com/franky-adl/threejs-synthwave-scene) ä¸­çš„`Starfield.png`å¤åˆ¶åˆ° assets æ–‡ä»¶å¤¹ä¸­ã€‚

ç”¨ä»¥ä¸‹å†…å®¹åˆ›å»ºä¸€ä¸ªæ–°æ–‡ä»¶`functions.js`:

```
import { maintainBgAspect } from "./common-utils"

/**
 * @param {object} scene the Three.js scene object
 * @param {object} image the path to the background image
 * @returns a Promise that resolves after the texture is loaded as the scene's background
 */
export const loadSceneBackground = (scene, image) => {
  return new Promise((resolve, reject) => {
    var loader = new THREE.TextureLoader();
    loader.load(image, function (texture) {
      scene.background = texture
      // position scene background such that image aspect ratio is preserved
      maintainBgAspect(scene, texture.image.width, texture.image.height)
      // need to maintain background aspect ratio across window resizes
      window.addEventListener("resize", () => {
        maintainBgAspect(scene, texture.image.width, texture.image.height)
      })
      resolve()
    }, undefined, function (error) {
      console.log(error)
      reject(error)
    });
  })
}
```

æˆ‘ä»¬ç”¨ä¸€ä¸ª`Promise`åŒ…è£…`TextureLoader.load()`å‡½æ•°çš„å›è°ƒï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥åœ¨`async initScene()`å‡½æ•°ä¸­ä½¿ç”¨`loadSceneBackground`ä¸Šçš„`await`è¡¨è¾¾å¼ã€‚

æˆ‘ä»¬å¸Œæœ›è¿™ä¸ª`Promise`åªæœ‰åœ¨çº¹ç†è¢«åŠ è½½æ—¶æ‰èƒ½è¢«è§£æï¼Œè¿™å°±æ˜¯ä¸ºä»€ä¹ˆæˆ‘ä»¬åœ¨ä¼ é€’ç»™`loader.load()`çš„`onLoad`å›è°ƒä¸­è°ƒç”¨`resolve()`ã€‚è¿™ç¡®ä¿äº†æˆ‘ä»¬çš„åœºæ™¯åªæœ‰åœ¨èƒŒæ™¯å®Œå…¨åŠ è½½åæ‰è¢«æ­å¼€ã€‚ç”±äº`core-utils.js`ä¸­çš„`runApp()`å‡½æ•°ä¸­çš„ä»£ç ï¼Œè¯¥æ­ç¤ºæœºåˆ¶èµ·ä½œç”¨:

```
app.initScene().then(() => {
  const veil = document.getElementById("veil")
  veil.style.opacity = 0
  return true
})
```

åå°åŠ è½½å‡½æ•°å°±ç»ªåï¼Œæˆ‘ä»¬éœ€è¦åœ¨ä¸»ç¨‹åºä¸­æ‰§è¡Œå®ƒã€‚

å¯¹`index.js`è¿›è¡Œä»¥ä¸‹ä»£ç æ›´æ”¹:

```
+ import { loadSceneBackground } from "./functions"
+ import Background from "./assets/Starfield.png"

...

let app = {
  async initScene() {
    // OrbitControls
    this.controls = new OrbitControls(camera, renderer.domElement)
    this.controls.enableDamping = true

+   // Environment
+   await loadSceneBackground(scene, Background)
```

ç°åœ¨æˆ‘ä»¬æœ‰äº†ç¹æ˜Ÿæ»¡å¤©çš„å¤œç©ºï¼å¾ˆå¥½å¾ˆå®¹æ˜“ã€‚

![](img/398825e054b78564fe2918d17a32daf1.png)

# 5.ä¸ºåœ°å½¢â›°è®¾ç½®å¹³é¢å‡ ä½•ä½“

é¦–å…ˆï¼Œå°†æˆ‘çš„`synthwave`å›è´­ä¸­çš„`heightmap.png`å¤åˆ¶åˆ° assets æ–‡ä»¶å¤¹ä¸­ã€‚

æ¥ä¸‹æ¥ï¼Œå°†ä¸‹é¢çš„ä»£ç æ·»åŠ åˆ°`common-utils.js`ä¸­:

```
/**
 * This loadImage function returns a Promise that is resolved when the image finishes loading
 * if you use it with await, it returns the loaded image object
 * @param {string} path image file path
 * @returns a Promise that resolves with the value assigned as the loaded image
 */
export const loadImage = (path) => {
    return new Promise((resolve, reject) => {
        const img = new Image()
        img.crossOrigin = "Anonymous" // to avoid CORS if used with Canvas
        img.src = path
        img.onload = () => {
            resolve(img)
        }
        img.onerror = (e) => {
            reject(e)
        }
    })
}
```

æˆ‘ä»¬å°†ä½¿ç”¨è¿™ä¸ªå‡½æ•°æ¥åŒæ­¥åŠ è½½æˆ‘ä»¬çš„`heightmap`ã€‚

ç„¶åï¼Œå°†ä»¥ä¸‹ä»£ç è¿½åŠ åˆ°`functions.js`ä¸­:

```
/**
 * original reference: https://gist.github.com/jawdatls/465d82f2158e1c4ce161
 * This function lets you get the greyscale color value from a specific point in an image
 * In this scenario, we pass in a displacement map as imageData,
 * and u/v values which gets translated to a certain point on the image
 * getting either one of r/g/b value as the displacement value is the same
 * since the image is supposed to be black and white
 * note that the direction of v axis in texture data is the inverse of the y axis in image data
 *
 * @param {object} imageData the color data of the displacement map image to be passed in
 * @param {number} u the x position [0,1] of the target pixel
 * @param {number} v the y position [0,1] of the target pixel
 * @param {number} cvWidth the width of the heightmap image in canvas
 * @param {number} cvHeight the height of the heightmap image in canvas
 * @returns {number} height value of the requested point within [0,5]
 */
export function getZFromImageDataPoint(imageData, u, v, cvWidth, cvHeight) {
  const mapWidth = cvWidth
  const mapHeight = cvHeight
  const displacementScale = 5
  var x = Math.round(u * (mapWidth - 1))
  var y = Math.round((1 - v) * (mapHeight - 1))
  var index = (y * imageData.width + x) * 4
  var red = imageData.data[index]
  return red / 255 * displacementScale
}
```

æˆ‘ä»¬å°†ä½¿ç”¨è¯¥å‡½æ•°ä»`heightmap.png`ä¸­æå–æ¯ä¸ªå¹³é¢é¡¶ç‚¹å¯¹åº”åƒç´ çš„é«˜åº¦å€¼ã€‚

è¯¥å‡½æ•°çš„`u`å’Œ`v`è¾“å…¥æ­£å¥½æ˜¯å¹³é¢é¡¶ç‚¹çš„ uv å€¼ã€‚è¯¥å‡½æ•°å°† uv åæ ‡è½¬æ¢ä¸ºå›¾åƒåæ ‡ã€‚

å¯¹äºè¿™ä¸€è¡Œä»£ç `var index = (y * imageData.width + x) * 4`ï¼Œ`y`å’Œ`x`æ˜¯å›¾åƒæ•°æ®ä¸­æ˜ å°„çš„è¡Œå·å’Œåˆ—å·ï¼Œä¹˜ä»¥ 4 æ˜¯å› ä¸º`imageData.data` é¡ºåºå­˜å‚¨æ‰€æœ‰åƒç´ çš„é¢œè‰²å€¼(å³ã€rï¼Œgï¼Œbï¼Œaï¼Œrï¼Œgï¼Œbï¼Œaï¼Œâ€¦ã€‘)ã€‚

å› æ­¤ï¼Œäº§ç”Ÿçš„`index`æ˜¯æ¯ä¸ªåƒç´ çš„ç¬¬ä¸€ä¸ªé¢œè‰²é€šé“ï¼Œä¸ºçº¢è‰²ã€‚æˆ‘ä»¬å¾—åˆ°å“ªä¸ªé¢œè‰²é€šé“å¹¶ä¸é‡è¦ï¼Œå› ä¸ºé«˜åº¦å›¾æ˜¯é»‘ç™½çš„ã€‚

æœ€åï¼Œæˆ‘ä»¬å°†è¯¥å€¼æ”¾å¤§ 5 å€ã€‚å› æ­¤ï¼Œè¯¥å‡½æ•°çš„è¿”å›å€¼åœ¨[0ï¼Œ5]çš„èŒƒå›´å†…ã€‚

è®©æˆ‘ä»¬åœ¨`index.js`ä¸­è¿›è¡Œä»¥ä¸‹ä»£ç æ›´æ”¹:

```
+ import { loadImage } from "./common-utils"
- import { loadSceneBackground } from "./functions"
+ import { loadSceneBackground, getZFromImageDataPoint } from "./functions"
import Background from "./assets/Starfield.png"
+ import HeightMap from "./assets/heightmap.png"

global.THREE = THREE

/**************************************************
 * 0\. Tweakable parameters for the scene
 *************************************************/
const params = {
  // general scene params
+ dirLightColor1: 0x2dd7ff,
+ dirLightColor2: 0x2dd7ff,
+ // plane params
+ metalness: 0.2,
+ roughness: 0.7,
+ meshColor: 0xffffff,
+ meshEmissive: 0x000098,
}
+ const terrainWidth = 30
+ const terrainHeight = 30
+ const lightPos1 = {
+   x: 15,
+   y: 1,
+   z: 5
+ }
+ const lightIntensity1 = 0.85
+ const lightPos2 = {
+   x: -15,
+   y: 1,
+   z: 5
+ }
+ const lightIntensity2 = 0.85

...

- let camera = createCamera(45, 1, 1000, { x: 0, y: 5, z: -15 })
+ let camera = createCamera(70, 1, 120, { x: 0, y: 0, z: 2.4 })

...

let app = {
  async initScene() {
    // OrbitControls
    this.controls = new OrbitControls(camera, renderer.domElement)
    this.controls.enableDamping = true

    // Environment
    await loadSceneBackground(scene, Background)

+   // Lighting
+   this.dirLight1 = new THREE.DirectionalLight(params.dirLightColor1, lightIntensity1)
+   this.dirLight1.position.set(lightPos1.x, lightPos1.y, lightPos1.z)
+   scene.add(this.dirLight1)
+   this.dirLight2 = new THREE.DirectionalLight(params.dirLightColor2, lightIntensity2)
+   this.dirLight2.position.set(lightPos2.x, lightPos2.y, lightPos2.z)
+   scene.add(this.dirLight2)

+   // load heightmap to a new image first, then read its color data to set the heights of our plane vertices
+   // see: https://gist.github.com/jawdatls/465d82f2158e1c4ce161
+   let hm_image = await loadImage(HeightMap)
+   var canvas = document.createElement("canvas")
+   canvas.width = hm_image.width
+   canvas.height = hm_image.height
+   var context = canvas.getContext("2d")
+   context.drawImage(hm_image, 0, 0)
+   var hm_imageData = context.getImageData(0, 0, canvas.width, canvas.height)

+   // Create a PlaneGeom
+   let planeGeometry = new THREE.PlaneGeometry(terrainWidth, terrainHeight, terrainWidth, terrainHeight)
+   let geometryPositions = planeGeometry.getAttribute("position").array
+   let geometryUVs = planeGeometry.getAttribute("uv").array

+   // update each vertex position's z value according to the value we extracted from the heightmap image
+   for (let index = 0; index < geometryUVs.length / 2; index++) {
+     let vertexU = geometryUVs[index * 2]
+     let vertexV = geometryUVs[index * 2 + 1]
+     // Update the z positions according to height map
+     let terrainHeight = getZFromImageDataPoint(hm_imageData, vertexU, vertexV, canvas.width, canvas.height)
+     geometryPositions[index * 3 + 2] = terrainHeight
+   }
+   // skew the plane geometry
+   const shearMtx = new THREE.Matrix4()
+   shearMtx.makeShear(-0.5, 0, 0, 0, 0, 0)
+   planeGeometry.applyMatrix4(shearMtx)

+   // material for the plane geometry
+   let meshMaterial = new THREE.MeshStandardMaterial({
+     color: new THREE.Color(params.meshColor),
+     emissive: new THREE.Color(params.meshEmissive),
+     metalness: params.metalness,
+     roughness: params.roughness,
+     flatShading: true
+   })

+   // create plane mesh and add to scene
+   let mesh = new THREE.Mesh(planeGeometry, meshMaterial)
+   mesh.position.set(0, -1.5, 0)
+   mesh.rotation.x -= Math.PI / 2
+   scene.add(mesh)

    // GUI controls
    const gui = new dat.GUI()
```

è¿™æ˜¯æ€ä¹ˆå›äº‹ï¼Ÿé¦–å…ˆï¼Œæˆ‘ä»¬æ·»åŠ ä¾èµ–å…³ç³»å’Œå¿…è¦çš„å˜é‡ï¼Œç”¨äºè®¾ç½®ç…§æ˜å’Œå¹³é¢å‡ ä½•ä½“+æè´¨ã€‚æˆ‘ä»¬è¿˜æ›´æ–°äº†æ‘„åƒæœºï¼Œä»¥ä¾¿æ›´å¥½åœ°è§‚å¯Ÿæˆ‘ä»¬çš„åœºæ™¯ï¼›æˆ‘å–œæ¬¢ä½¿ç”¨æ›´å¤§çš„`fov`ï¼Œè¿™æ ·åœºæ™¯çœ‹èµ·æ¥æ›´å®½ã€‚

ç„¶ååœ¨`initScene()`ä¸­ï¼Œæˆ‘ä»¬æ·»åŠ äº†ä¸¤ä¸ª`DirectionalLight`æ¥ç…§å°„å·¦å³ä¸¤è¾¹çš„å±±ä½“ã€‚å¦‚æœæ²¡æœ‰å…‰çº¿ï¼Œæ•´ä¸ªåœ°å½¢ä¼šæœ‰ç›¸åŒçš„é¢œè‰²ï¼Œæ²¡æœ‰æ˜æš—å˜åŒ–ã€‚

ä¹‹åï¼Œæˆ‘ä»¬åˆ›å»ºä¸€ä¸ª`canvas`å¯¹è±¡æ¥å­˜å‚¨åŠ è½½çš„é«˜åº¦å›¾å›¾åƒï¼Œå¹¶é€šè¿‡`context.getImageData()`å°†å›¾åƒæ•°æ®ä¿å­˜åˆ°`hm_imageData`ä¸­ã€‚ä¸è¦æ‹…å¿ƒï¼Œè¿™ä¸ªç”»å¸ƒæ²¡æœ‰æ·»åŠ åˆ°æ–‡æ¡£ä¸­ï¼Œå› æ­¤åœ¨å±å¹•ä¸Šæ˜¯ä¸å¯è§çš„ã€‚

ç„¶åæˆ‘ä»¬åˆ›å»ºä¸€ä¸ªå…·æœ‰ç›¸åŒå®½åº¦å’Œé«˜åº¦(è®¾ç½®ä¸º 30)çš„æ­£æ–¹å½¢`planeGeometry`ï¼Œä¸ºç®€å•èµ·è§ï¼Œå®½åº¦/é«˜åº¦æ®µä¹Ÿå…·æœ‰ç›¸åŒçš„å€¼ã€‚æˆ‘ä»¬ä»æ™®é€šçš„`PlaneGeometry`ä¸­æå–å‡º`BufferAttribute`ä¸­çš„`position`å’Œ`uv`æ•°ç»„ä»¥å¤‡åç”¨ã€‚

ç„¶åæˆ‘ä»¬éå†æ‰€æœ‰çš„é¡¶ç‚¹æ¥è®¾ç½®æ¯ä¸ªé¡¶ç‚¹çš„é«˜åº¦å€¼ã€‚æˆ‘ä»¬ä½¿ç”¨`getZFromImageDataPoint()`æ¥è·å¾—é«˜åº¦å›¾ä¸Šæ¯ä¸ªé¡¶ç‚¹å¯¹åº”çš„é«˜åº¦å€¼ã€‚çœ‹çœ‹ for å¾ªç¯ï¼Œ`geometryUVs.length / 2`è¡¨ç¤ºé¡¶ç‚¹çš„æ€»æ•°ï¼Œå› ä¸º`BufferAttribute`æ•°ç»„åœ¨ä¸€ä¸ªå±‚ä¸­é¡ºåºå­˜å‚¨å€¼ï¼Œè€Œä¸æ˜¯åµŒå¥—æ¯ä¸ªé¡¶ç‚¹çš„ xï¼Œyï¼Œz æˆ– uï¼Œv å€¼ï¼›è§ä¸‹å›¾ã€‚

![](img/37f4e1ef68b7862b12685cef3b45bbfe.png)

æ¯ä¸ª BufferAttribute çš„æ•°ç»„ç»“æ„ï¼Œå›¾ç‰‡æ¥è‡ª[https://threejs.org/manual/#en/custom-buffergeometry](https://threejs.org/manual/#en/custom-buffergeometry)

è¿™å°±æ˜¯ä¸ºä»€ä¹ˆåœ¨`geometryPositions[index * 3 + 2]`ä¸­ï¼Œwe ä¹˜ä»¥ 3 å› ä¸ºæ¯ä¸ªé¡¶ç‚¹æœ‰ 3 ä¸ªä½ç½®å€¼ xï¼Œyï¼Œzï¼ŒåŠ  2 å°±æ˜¯å¾—åˆ° z å€¼ã€‚

ç°åœ¨æˆ‘ä»¬å·²ç»ä¸ºæ¯ä¸ªé¡¶ç‚¹è®¾ç½®äº†æ­£ç¡®çš„é«˜åº¦ï¼Œæˆ‘ä»¬ä»ç„¶éœ€è¦æ²¿ç€ y æ–¹å‘å‰ªåˆ‡å¹³é¢ã€‚æˆ‘æ²¡æœ‰çœŸæ­£æ·±å…¥åˆ°`makeShear`å‡½æ•°çš„æºä»£ç ä¸­ï¼Œä½†æ˜¯å¦‚æœæˆ‘æ²¡æœ‰å¼„é”™çš„è¯ï¼Œç”¨`0.5`å‰ªåˆ‡å®ƒåº”è¯¥æ˜¯æ­£ç¡®çš„å¹…åº¦ã€‚

![](img/42bf7eb434ab18a8a86eed95ca1c576f.png)

æˆ‘ä»¬æƒ³æ²¿ç€ y è½´å‰ªåˆ‡å®ƒï¼Œç›´åˆ°å›¾æ¡ˆçœ‹èµ·æ¥åƒä¸€å¯¹å¯¹ç§°ä¸‰è§’å½¢çš„ç»„åˆ

![](img/05048d0a396b7d99ce3a33fa23503f0a.png)

è™šçº¿è¡¨ç¤ºæ™®é€šå¹³é¢å‡ ä½•å½¢çŠ¶çš„ä¸€ä¸ªå•å…ƒï¼Œå®çº¿è¡¨ç¤ºå‰ªåˆ‡çŠ¶æ€

æˆ‘ä»¬åˆ›å»ºçš„æ™®é€šå¹³é¢å‡ ä½•ä½“ç”±æ­£æ–¹å½¢ç»„æˆï¼Œå› ä¸ºå®½åº¦å’Œé«˜åº¦å€¼ä¸å®½åº¦å’Œé«˜åº¦éƒ¨åˆ†ç›¸åŒã€‚æˆ‘ä»¬æƒ³åœ¨ y æ–¹å‘å‰ªåˆ‡å®ƒä¸€åŠçš„æ­£æ–¹å½¢é•¿åº¦`l/2`ã€‚æŸ¥çœ‹ä¸Šé¢ç®€åŒ–çš„ 2d å‰ªåˆ‡æ–¹ç¨‹ï¼Œå¦‚æœæˆ‘ä»¬å°†å‰ªåˆ‡å› å­`s`è®¾ç½®ä¸º 0.5ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¾—åˆ°çš„åæ ‡å°†æ˜¯`(x, y + 0.5x)`ã€‚ä»£å…¥`x = l`ï¼Œå‰ªåˆ‡çš„é‡å°±æ˜¯`l/2`ï¼Œè¿™å°±æ˜¯æˆ‘ä»¬æƒ³è¦çš„é‡ã€‚

[è¿™ä¸ªè§†é¢‘](https://www.youtube.com/watch?v=cxbTV5Jjm6s)å¾ˆå¥½åœ°è§£é‡Šäº†å‰ªåˆ‡æ¦‚å¿µã€‚

å¯¹äºå¹³é¢æè´¨ï¼Œæˆ‘ä»¬ä½¿ç”¨`MeshStandardMaterial`ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ä½¿ç”¨`metalness`å’Œ`roughness`è¿›è¡Œè°ƒæ•´ã€‚æ‰“å¼€`flatShading`å¾ˆé‡è¦ï¼Œå› ä¸ºè§†è§‰æ ·å¼æ›´é€‚åˆä½å¤šè¾¹å½¢çš„å¯¹è±¡ã€‚

åº”ç”¨æ‰€æœ‰æ›´æ”¹åï¼Œæ‚¨çš„åœºæ™¯ç°åœ¨åº”è¯¥å¦‚ä¸‹æ‰€ç¤º:

![](img/cec0aae3ea400429ae737baf069bffea.png)

# 6.åœ¨åœ°å½¢ä¸Šåˆ›å»ºäº®/éœ“è™¹ç½‘æ ¼çº¿

æœ€åˆï¼Œæˆ‘å°è¯•ä½¿ç”¨`WireframeGeometry`å’Œ`LineSegments`æ¥åˆ›å»ºç½‘æ ¼çº¿ï¼Œä½†æ˜¯æœ‰ä¸€ä¸ªä¸¥é‡çš„é™åˆ¶ã€‚é—æ†¾çš„æ˜¯ï¼Œä½¿ç”¨çš„`LineBasicMaterial`è¢«é™åˆ¶ä¸º`linewidth`æ€»æ˜¯ä¸º 1ï¼Œè€Œä¸ç®¡è®¾ç½®äº†ä»€ä¹ˆå€¼ã€‚

å¹¸è¿çš„æ˜¯ï¼Œè¿˜æœ‰å¦ä¸€ç§æ–¹æ³•æ¥å®ç°å¯é…ç½®ç²—ç»†çš„çº¿æ¡ã€‚æŒ‰ç…§[è¿™ä¸ªä¾‹å­](https://threejs.org/examples/?q=fat#webgl_lines_fat)æ¼”ç¤ºçš„æ–¹æ³•ï¼Œæˆ‘ä»¬èƒ½å¤Ÿæ§åˆ¶çº¿æ¡çš„ç²—ç»†ã€‚ä½†æ˜¯å¦‚æœæˆ‘ä»¬è¦å®ç°è¿™ä¸ªæ–¹æ³•ï¼Œæˆ‘ä»¬å°†éœ€è¦æ³¨å…¥äº†é«˜åº¦å›¾æ•°æ®çš„å¹³é¢å‡ ä½•çš„é¡¶ç‚¹ä½ç½®ã€‚

è¿™å°±æ˜¯ä¸ºä»€ä¹ˆéœ€è¦æ‰‹åŠ¨è®¡ç®—æ¯ä¸ªé¡¶ç‚¹çš„ z å€¼ï¼Œè€Œä¸æ˜¯ç®€å•åœ°å°†`heightmap`åˆ†é…ç»™æè´¨çš„`displacementMap`å±æ€§(å¦‚ç¬¬ 2 èŠ‚æ‰€è¿°)ã€‚

åœ¨`index.js`ä¸­è¿›è¡Œä»¥ä¸‹æ›´æ”¹:

```
import Stats from "three/examples/jsm/libs/stats.module"
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls"
+ import { LineGeometry } from "three/examples/jsm/lines/LineGeometry"
+ import { LineMaterial } from "three/examples/jsm/lines/LineMaterial"
+ import { Line2 } from "three/examples/jsm/lines/Line2"

...

const params = {
  // general scene params
  dirLightColor1: 0x2dd7ff,
  dirLightColor2: 0x2dd7ff,
  // plane params
  metalness: 0.2,
  roughness: 0.7,
  meshColor: 0xffffff,
  meshEmissive: 0x000098,
+ lineWidth: 0.04,
+ lineColor: 0xcee4ff,
}

...

- let renderer = createRenderer({ antialias: true }, (_renderer) => {
+ let renderer = createRenderer({ antialias: true, logarithmicDepthBuffer: true }, (_renderer) => {

...

let app = {
  async initScene() {
    ...

+   // the grid lines, reference: https://threejs.org/examples/?q=line#webgl_lines_fat
+   let lineGeometry = new LineGeometry()
+   let linePositions = []
+   // This is a specific way to map line points to cooresponding vertices of the planeGeometry
+   for (let row = 0; row < terrainHeight; row++) {
+     let isEvenRow = row % 2 == 0
+     for (let col = (isEvenRow ? 0 : (terrainWidth - 1)); isEvenRow ? (col < terrainWidth) : (col >= 0); isEvenRow ? col++ : col--) {
+       for (let point = (isEvenRow ? 0 : 3); isEvenRow ? (point < 4) : (point >= 0); isEvenRow ? point++ : point--) {
+         let mappedIndex
+         let rowOffset = row * (terrainWidth + 1)
+         if (point < 2) {
+           mappedIndex = rowOffset + col + point
+         } else {
+           mappedIndex = rowOffset + col + point + terrainWidth - 1
+         }

+         linePositions.push(geometryPositions[mappedIndex * 3])
+         linePositions.push(geometryPositions[mappedIndex * 3 + 1])
+         linePositions.push(geometryPositions[mappedIndex * 3 + 2])
+       }
+     }
+   }
+   lineGeometry.setPositions(linePositions)

+   // the material for the grid lines
+   let lineMaterial = new LineMaterial({
+     color: params.lineColor,
+     linewidth: params.lineWidth, // in world units with size attenuation, pixels otherwise
+     alphaToCoverage: false,
+     worldUnits: true // such that line width depends on world distance
+   })

    // create plane mesh and add to scene
    let mesh = new THREE.Mesh(planeGeometry, meshMaterial)
    mesh.position.set(0, -1.5, 0)
    mesh.rotation.x -= Math.PI / 2
    scene.add(mesh)

+   // create the lines mesh and add to scene
+   let line = new Line2(lineGeometry, lineMaterial)
+   line.computeLineDistances()
+   line.position.set(0, -1.5, 0)
+   line.rotation.x -= Math.PI / 2
+   scene.add(line)

    // GUI controls
    const gui = new dat.GUI()
```

æ³¨æ„ï¼Œæˆ‘ä»¬æ‰“å¼€äº†æ¸²æŸ“å™¨çš„`logarithmicDepthBuffer`ã€‚æ­¤é…ç½®ä¿®å¤äº†ç½‘æ ¼çº¿å’Œå¹³é¢å‡ ä½•ä½“ä¹‹é—´çš„ z æˆ˜æ–—é—®é¢˜ã€‚åœ¨[https://threejs.org/manual/#en/cameras](https://threejs.org/manual/#en/cameras)çš„ä¸‹åŠéƒ¨åˆ†é˜…è¯»æ›´å¤šå…³äºè¿™ä¸ªé—®é¢˜çš„å†…å®¹ã€‚

å¦å¤–ï¼Œè¯·æ³¨æ„ï¼Œ`LineGeometry`ã€`LineMaterial`å’Œ`Line2`ç±»ä¸æ˜¯æ¥è‡ªæ ¸å¿ƒçš„ Three.js åº“ã€‚å®ƒä»¬æ˜¯ä»`jsm`æ–‡ä»¶å¤¹å¯¼å…¥çš„ã€‚

`LineGeometry`çš„å·¥ä½œæ–¹å¼æ˜¯å®ƒéœ€è¦ä¸€ä¸ªé¡¶ç‚¹ä½ç½®çš„é¡ºåºæ•°ç»„ï¼Œç„¶åå®ƒä¼šç”»ä¸€æ¡çº¿ï¼Œä»¥ç›¸åŒçš„é¡ºåºè¿æ¥ä½ç½®æ•°ç»„ä¸­æŒ‡å®šçš„ç‚¹ã€‚æ‰€ä»¥åŸºæœ¬ä¸Šåªç”»äº†ä¸€æ¡çº¿ï¼Œä»å¤´åˆ°å°¾ã€‚

ä¸‰é‡åµŒå¥—çš„ for å¾ªç¯ä»£ç å—æ‰€åšçš„æ˜¯æ­£ç¡®è®¾ç½®é¡¶ç‚¹çš„é¡ºåºæ•°ç»„ã€‚æˆ‘ç”¨ä¸€ä¸ªç®€å•çš„ä¾‹å­æ¥è§£é‡Šã€‚

æ¯”æ–¹è¯´å¦‚æœæˆ‘ä»¬æ ¹æœ¬ä¸è®¡ç®—`linePositions`ç›´æ¥ç”¨å¹³é¢å‡ ä½•çš„`geometryPositions`:

```
lineGeometry.setPositions(geometryPositions)
```

ä½ çœ‹åˆ°çš„ä¼šæ˜¯æ··ä¹±çš„:

![](img/8109c55e66ad3c851cd47f068d164dbc.png)

åŸå› æ˜¯é¡¶ç‚¹ä½ç½®çš„é»˜è®¤é¡ºåºæ˜¯ä»å·¦åˆ°å³é€è¡Œæ’åˆ—çš„ã€‚æŸ¥çœ‹å¸¦æœ‰æ•°å­—è¾…åŠ©å¯¹è±¡çš„å¹³é¢å‡ ä½•ä½“ï¼Œè¿™äº›è¾…åŠ©å¯¹è±¡æ ‡è®°äº†ä¸‹é¢çš„æ¯ä¸ªé¡¶ç‚¹:

![](img/31b3c94a3b209f80456c07a7ad8496ea.png)

ä½äº[https://hofk . de/main/discourse . three js/2022/three n/numberinghelperexamples . html](https://hofk.de/main/discourse.threejs/2022/THREEn/NumberingHelperExamples.html)çš„ç¤ºä¾‹æˆªå›¾

å› æ­¤ï¼Œæ­£åœ¨ç»˜åˆ¶çš„çº¿åªæ˜¯éµå¾ªé¡¶ç‚¹é¡ºåºï¼Œç»“æœæ˜¯è¿™æ ·çš„(è“çº¿):

![](img/e9f4ce483366345216fb01522e1fea64.png)

æ¯ä¸€è¡Œéƒ½æ˜¯ä»æœ€å³è¾¹åˆ°æœ€å·¦è¾¹ï¼Œéš¾æ€ªæˆ‘ä»¬ä¼šçœ‹åˆ°ä¸€ç‰‡æ··ä¹±

ä¸ºäº†é˜²æ­¢è¡Œä»å³è¾¹ç¼˜è·³åˆ°å·¦è¾¹ç¼˜ï¼Œæˆ‘ä»¬å¿…é¡»ä»¥ç‰¹å®šçš„æ–¹å¼æ’åˆ—è¡Œçš„ä½ç½®ã€‚

å¯¹äºç¬¬ä¸€è¡Œï¼Œæˆ‘ä»¬åº”è¯¥æŒ‰ç…§é¡¶ç‚¹é¡ºåºç»˜åˆ¶ç›´çº¿:

v0 â€” v1 â€” v5 â€” v6ï¼Œæ¥ç€æ˜¯ v1 â€” v2 â€” v6 â€” v7ï¼Œä¾æ­¤ç±»æ¨ã€‚

ç„¶è€Œï¼Œå¯¹äºç¬¬äºŒè¡Œï¼Œæˆ‘ä»¬å¿…é¡»ä»å³ä¾§å¼€å§‹ï¼Œè€Œä¸æ˜¯ä»å·¦ä¾§å¼€å§‹ï¼Œå› ä¸ºå¦åˆ™ï¼Œæˆ‘ä»¬ä¼šé‡åˆ°åŒæ ·çš„é—®é¢˜ï¼Œå³ç›´çº¿ä»å³è¾¹ç¼˜è·³åˆ°å·¦è¾¹ç¼˜ã€‚æ‰€ä»¥åŸºæœ¬ä¸Šï¼Œå¯¹äºå¶æ•°è¡Œï¼Œæˆ‘ä»¬å¿…é¡»æŒ‰ç…§å¥‡æ•°è¡Œçš„ç›¸åé¡ºåºæ’åˆ—é¡¶ç‚¹ã€‚

å› æ­¤ï¼Œå¯¹äºç¬¬äºŒè¡Œï¼Œæˆ‘ä»¬åº”è¯¥éµå¾ªä»¥ä¸‹é¡¶ç‚¹é¡ºåº:

v14 â€” v13 â€” v9 â€” v8ï¼Œæ¥ç€æ˜¯ v13 â€” v12 â€” v8 â€” v7ï¼Œä¾æ­¤ç±»æ¨ã€‚

é€šè¿‡å®æ–½è¿™ç§ç‰¹æ®Šçš„æ’åºï¼Œæˆ‘ä»¬å¯ä»¥åœ¨æˆ‘ä»¬çš„åœ°å½¢ä¸Šè·å¾—ä¸€ä¸ªå®Œç¾çš„çº¿ç½‘æ ¼:

![](img/ade7fb9cf055f944ed1f57533234d789.png)

èµ°è¿‘æˆ‘ä»¬çš„æœ€ç»ˆäº§å“ï¼

# 7.åˆ›é€ ä¸€ä¸ªæ²¡æœ‰å°½å¤´çš„åœ°å½¢çš„å¹»è§‰

è¿™ä¸ªé¡¹ç›®ä»¤äººå…´å¥‹çš„éƒ¨åˆ†æ¥äº†:ä¼ªé€ ä¸€ä¸ªæ°¸æ— æ­¢å¢ƒçš„åœ°å½¢ï¼

å¦‚æœæ‚¨è·³è¿‡äº†ä¸Šé¢ç¬¬ 2 éƒ¨åˆ†çš„è§£é‡Šï¼Œæˆ‘å°†å¿«é€Ÿå›é¡¾ä¸€ä¸‹è¿™ä¸ªæ¦‚å¿µ:

1.  åˆ¶ä½œå‡ ç»„åœ°å½¢å›¾
2.  åƒç«è½¦ä¸€æ ·æŠŠä»–ä»¬è¿æ¥èµ·æ¥
3.  è®©ç«è½¦æœç€æ‘„åƒæœºç§»åŠ¨
4.  å¼¹å‡ºç«è½¦å¤´éƒ¨ï¼Œå¦‚æœå®ƒåœ¨æ‘„åƒæœºåé¢ï¼Œå°±æŠŠå®ƒæ”¾å›å°¾éƒ¨ã€‚
5.  ç§å•Šã€‚è¿™å°±æ˜¯ä½ å¦‚ä½•ä¼ªé€ ä¸€ä¸ªæ— å°½çš„åœ°å½¢ã€‚

åœ¨æˆ‘çš„å¼€å‘è¿‡ç¨‹ä¸­ï¼Œæˆ‘å‘ç°ä¸ºæ‰€æœ‰è¿ç»­çš„åœ°å½¢å…‹éš†åªé‡å¤ä¸€ä¸ªé«˜åº¦å›¾åœ¨è§†è§‰ä¸Šå¤ªé‡å¤äº†ï¼Œæ‰€ä»¥æˆ‘åšäº†ä¸€ä¸ªå¿«é€Ÿä¿®å¤ï¼Œä½¿åœ°å½¢çœ‹èµ·æ¥ä¸é‚£ä¹ˆé‡å¤ï¼›é€šè¿‡æ°´å¹³ç¿»è½¬é«˜åº¦å›¾æ¥â€œåˆ›å»ºâ€ç¬¬äºŒä¸ªé«˜åº¦å›¾ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¯¹äºâ€œå¥‡æ•°â€åœ°å½¢ä½¿ç”¨é«˜åº¦å›¾ï¼Œè€Œå¯¹äºâ€œå¶æ•°â€åœ°å½¢åè½¬é«˜åº¦å›¾ã€‚

è®©æˆ‘ä»¬åœ¨`index.js`ä¸­è¿›è¡Œä»¥ä¸‹ä»£ç æ›´æ”¹:

```
/**************************************************
 * 0\. Tweakable parameters for the scene
 *************************************************/
const params = {
  // general scene params
+ speed: 2.5,

...

const lightIntensity2 = 0.85
+ // need to be even number since the consecutive terrains are stitched in pairs
+ const numOfMeshSets = 6

...

let app = {
  async initScene() {
    ...
    scene.add(this.dirLight2)

+   // create sets of objects, for the capability to use different heightmaps for each set of plane and lines
+   let planeGeometries = []
+   let lineGeometries = []
+   let geometryPositionsArray = []

+   // we only loop twice here, although we load a single HeightMap, the trick is:
+   // first loop we load the HeightMap the normal way
+   // second loop we load the HeightMap data horizontally inversed
+   for (let i = 0; i < 2; i++) {
      // load heightmap to a new image first, then read its color data to set the heights of our plane vertices
      // see: https://gist.github.com/jawdatls/465d82f2158e1c4ce161
      let hm_image = await loadImage(HeightMap)
      var canvas = document.createElement("canvas")
      canvas.width = hm_image.width
      canvas.height = hm_image.height
      var context = canvas.getContext("2d")
      context.drawImage(hm_image, 0, 0)
      var hm_imageData = context.getImageData(0, 0, canvas.width, canvas.height)

      // Create a PlaneGeom
      let planeGeometry = new THREE.PlaneGeometry(terrainWidth, terrainHeight, terrainWidth, terrainHeight)
      let geometryPositions = planeGeometry.getAttribute("position").array
      let geometryUVs = planeGeometry.getAttribute("uv").array

      // update each vertex position's z value according to the value we extracted from the heightmap image
      for (let index = 0; index < geometryUVs.length / 2; index++) {
        let vertexU = geometryUVs[index * 2]
        let vertexV = geometryUVs[index * 2 + 1]
-       // Update the z positions according to height map,
-       let terrainHeight = getZFromImageDataPoint(hm_imageData, vertexU, vertexV, canvas.width, canvas.height)
+       // Update the z positions according to height map, inverse heightmap horizontally for the second loop
+       let terrainHeight = getZFromImageDataPoint(hm_imageData, (i == 0 ? vertexU : 1 - vertexU), vertexV, canvas.width, canvas.height)
        geometryPositions[index * 3 + 2] = terrainHeight
      }
      // skew the plane geometry
      const shearMtx = new THREE.Matrix4()
      shearMtx.makeShear(-0.5, 0, 0, 0, 0, 0)
      planeGeometry.applyMatrix4(shearMtx)

+     planeGeometries.push(planeGeometry)
+     geometryPositionsArray.push(geometryPositions)
+   }

+   // zip up the gaps between the 1st and 2nd plane geometries
+   for (let index = 0; index <= terrainWidth; index++) {
+     let bottomOffset = (terrainWidth + 1) * terrainHeight
+     // 2nd geom's bottom row height should be synced with 1st geom's top
+     geometryPositionsArray[1][(bottomOffset + index) * 3 + 2] = geometryPositionsArray[0][index * 3 + 2]
+     // 1st geom's bottom row height should be synced with 2nd geom's top
+     geometryPositionsArray[0][(bottomOffset + index) * 3 + 2] = geometryPositionsArray[1][index * 3 + 2]
+   }

    // material for the plane geometry
    let meshMaterial = new THREE.MeshStandardMaterial({
      color: new THREE.Color(params.meshColor),
      emissive: new THREE.Color(params.meshEmissive),
      metalness: params.metalness,
      roughness: params.roughness,
      flatShading: true
    })

    // the grid lines, reference: https://threejs.org/examples/?q=line#webgl_lines_fat
+   for (let i = 0; i < 2; i++) {
      let lineGeometry = new LineGeometry()
      let linePositions = []
      // This is a specific way to map line points to corresponding vertices of the planeGeometry
      for (let row = 0; row < terrainHeight; row++) {
        let isEvenRow = row % 2 == 0
        for (let col = (isEvenRow ? 0 : (terrainWidth - 1)); isEvenRow ? (col < terrainWidth) : (col >= 0); isEvenRow ? col++ : col--) {
          for (let point = (isEvenRow ? 0 : 3); isEvenRow ? (point < 4) : (point >= 0); isEvenRow ? point++ : point--) {
            let mappedIndex
            let rowOffset = row * (terrainWidth + 1)
            if (point < 2) {
              mappedIndex = rowOffset + col + point
            } else {
              mappedIndex = rowOffset + col + point + terrainWidth - 1
            }

-           linePositions.push(geometryPositions[mappedIndex * 3])
-           linePositions.push(geometryPositions[mappedIndex * 3 + 1])
-           linePositions.push(geometryPositions[mappedIndex * 3 + 2])
+           linePositions.push(geometryPositionsArray[i][mappedIndex * 3])
+           linePositions.push(geometryPositionsArray[i][mappedIndex * 3 + 1])
+           linePositions.push(geometryPositionsArray[i][mappedIndex * 3 + 2])
          }
        }
      }
      lineGeometry.setPositions(linePositions)

+     lineGeometries.push(lineGeometry)
+   }

-   // create plane mesh and add to scene
-   let mesh = new THREE.Mesh(planeGeometry, meshMaterial)
-   mesh.position.set(0, -1.5, 0)
-   mesh.rotation.x -= Math.PI / 2
-   scene.add(mesh)
-   // create the lines mesh and add to scene
-   let line = new Line2(lineGeometry, lineMaterial)
-   line.computeLineDistances()
-   line.position.set(0, -1.5, 0)
-   line.rotation.x -= Math.PI / 2
-   scene.add(line)

+   this.meshGroup = []
+   this.lineGroup = []
+   // create multiple sets of plane and line meshes determined by numOfMeshSets
+   for (let i = 0; i < numOfMeshSets; i++) {
+     // create the meshes
+     let mesh = new THREE.Mesh(planeGeometries[i % 2], meshMaterial)
+     let line = new Line2(lineGeometries[i % 2], lineMaterial)
+     line.computeLineDistances()
+     // set the correct pos and rot for both the terrain and its wireframe
+     mesh.position.set(0, -1.5, -terrainHeight * i)
+     mesh.rotation.x -= Math.PI / 2
+     line.position.set(0, -1.5, -terrainHeight * i)
+     line.rotation.x -= Math.PI / 2
+     // add the meshes to the scene
+     scene.add(mesh)
+     scene.add(line)
+     this.meshGroup.push(mesh)
+     this.lineGroup.push(line)
+   }

...

  // @param {number} interval - time elapsed between 2 frames
  // @param {number} elapsed - total time elapsed since app start
  updateScene(interval, elapsed) {
    this.controls.update()
    this.stats1.update()

+   for (let i = 0; i < numOfMeshSets; i++) {
+     this.meshGroup[i].position.z += interval * params.speed
+     this.lineGroup[i].position.z += interval * params.speed
+     if (this.meshGroup[i].position.z >= terrainHeight) {
+       this.meshGroup[i].position.z -= numOfMeshSets * terrainHeight
+       this.lineGroup[i].position.z -= numOfMeshSets * terrainHeight
+     }
+   }
  }
```

æˆ‘ä»¬å®šä¹‰äº†ä¸€ä¸ªæ–°çš„`speed`å‚æ•°æ¥æ§åˆ¶åœ°å½¢ç§»åŠ¨çš„é€Ÿåº¦ã€‚æˆ‘ä»¬è¿˜å®šä¹‰äº†ä¸€ä¸ªæ–°çš„`numOfMeshSets`å˜é‡æ¥æ§åˆ¶æˆ‘ä»¬æƒ³è¦åˆ›å»ºå¤šå°‘åœ°å½¢å‰¯æœ¬ã€‚

ç°åœ¨ï¼Œæˆ‘ä»¬å®šä¹‰å˜é‡`planeGeometries`ã€`lineGeometries`å’Œ`geometryPositionsArray`æ¥å­˜å‚¨ä¸¤ç»„å‡ ä½•å›¾å½¢ï¼Œæ¯ç»„éƒ½æ˜¯ç”±äºä½¿ç”¨çš„`heightmaps`ä¸åŒè€Œäº§ç”Ÿçš„ã€‚

ç„¶åï¼Œæˆ‘ä»¬å°†å¹³é¢å’Œçº¿å‡ ä½•è®¾ç½®ä»£ç åŒ…è£…åœ¨ä¸€ä¸ª 2 åœˆçš„ for å¾ªç¯ä¸­ã€‚åœ¨å¹³é¢å‡ ä½•è®¾ç½®çš„ç¬¬äºŒä¸ªå¾ªç¯ä¸­ï¼Œæˆ‘ä»¬å°†`1 â€” vertexU`ä¼ é€’ç»™`u`å‚æ•°æ¥å®ç°æ°´å¹³åè½¬é«˜åº¦å›¾çš„æ•ˆæœã€‚

åœ¨`runApp()`ä¸­è®¾ç½®çš„åŠ¨ç”»å¾ªç¯æ¯ä¸€å¸§éƒ½ä¼šè°ƒç”¨`updateScene()`åŠŸèƒ½ã€‚è¿™é‡Œæ·»åŠ çš„ä»£ç æ˜¯æ— ä¼‘æ­¢åœ°æ¿€æ´»åœ°å½¢çš„ä¸œè¥¿ã€‚ç›¸æœºè®¾ç½®ä¹Ÿæ˜¯ä¸€ä¸ªå› ç´ ã€‚ç”±äºå…¶`far`å€¼è®¾ç½®ä¸º 120ï¼Œè€Œâ€œåœ°å½¢åˆ—è½¦â€çš„å¯è§é•¿åº¦çº¦ä¸º 150 è‡³ 180ï¼Œæˆ‘ä»¬å°†æ°¸è¿œä¸ä¼šçœ‹åˆ°å¼¹å‡ºçš„åœ°å½¢æŠ–åŠ¨è¢«æ·»åŠ å›åˆ—è½¦å°¾éƒ¨ã€‚

å˜åŒ–ä¹‹åï¼Œä½ ä¼šçœ‹åˆ°åœ°å½¢ä¸æ–­å‘ä½ ç§»åŠ¨ã€‚

![](img/ac9c91a9066266f7e300114ebf69c563.png)

åœ¨æ°¸æ— æ­¢å¢ƒçš„åœ°å½¢ä¸­å‰è¿›çš„é”™è§‰

# 8.æ·»åŠ è½æ—¥â˜€å¹¶åˆ¶ä½œåŠ¨ç”»

è¿™ä¹Ÿæ˜¯ä¸€ä¸ªæœ‰è¶£çš„éƒ¨åˆ†ï¼Œä½†æ¶‰åŠåˆ°è¿™ä¸ªé¡¹ç›®ä¸­æœ€å¤æ‚çš„æ•°å­¦ã€‚æˆ‘èŠ±äº†ä¸€äº›æ—¶é—´æ¥æ‰¾å‡ºæ­£ç¡®çš„å…¬å¼æ¥åˆ¶ä½œå¤ªé˜³ä¸Šè¿™äº›æ¡çº¹çš„åŠ¨ç”»ã€‚æˆ‘ä½¿ç”¨è‡ªå®šä¹‰ç€è‰²å™¨ï¼Œä»¥åŠ¨ç”»å¤ªé˜³çš„é¢œè‰²ã€‚å¦‚æœä½ ä¸ç†Ÿæ‚‰è¿™ä¸ªä¸»é¢˜ï¼Œè¯·é˜…è¯»å…³äº[https://thebookofshaders.com/](https://thebookofshaders.com/)çš„ç€è‰²å™¨ã€‚

å°†ä»¥ä¸‹ä»£ç é™„åŠ åˆ°`functions.js`:

```
// vertexShader for the Sun
export function vertexShader() {
  return `
      varying vec2 vUv;
      varying vec3 vPos;
      void main() {
        vUv = uv;
        vPos = position;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); 
      }
  `
}

// fragmentShader for the Sun
export function fragmentShader() {
  return `
      #ifdef GL_ES
      precision mediump float;
      #endif
      #define PI 3.14159265359
      #define TWO_PI 6.28318530718

      uniform vec2 u_resolution;
      uniform vec2 u_mouse;
      uniform float u_time;
      uniform vec3 color_main;
      uniform vec3 color_accent;
      varying vec2 vUv;
      varying vec3 vPos;
      void main() {
        vec2 st = gl_FragCoord.xy/u_resolution.xy;
        float x = vPos.y;
        float osc = ceil(sin((3\. - (x - u_time) / 1.5) * 5.) / 2\. + 0.4 - floor((3\. - x / 1.5) * 5\. / TWO_PI) / 10.);
        vec3 color = mix(color_accent, color_main, smoothstep(0.2, 1., vUv.y));
        gl_FragColor = vec4(color, osc);
      }
  `
}
```

æˆ‘å¾ˆä¹æ„èŠ±æ›´å¤šçš„æ—¶é—´æ¥è§£é‡Š`fragmentShader`ä¸­çš„ä»£ç ï¼Œä½†æ˜¯æˆ‘æ‹…å¿ƒè¿™ç¯‡æ–‡ç« ä¼šå˜å¾—å¤ªé•¿ã€‚

æ¥ä¸‹æ¥ï¼Œå¯¹`index.js`è¿›è¡Œå¦‚ä¸‹æ›´æ”¹:

```
- import { createCamera, createComposer, createRenderer, runApp } from "./core-utils"
+ import { createCamera, createComposer, createRenderer, runApp, getDefaultUniforms } from "./core-utils"

- import { loadImage} from "./common-utils"
- import { loadSceneBackground, getZFromImageDataPoint } from "./functions"
+ import { loadImage, hexToRgb } from "./common-utils"
+ import { loadSceneBackground, getZFromImageDataPoint, vertexShader, fragmentShader } from "./functions"

...

/**************************************************
 * 0\. Tweakable parameters for the scene
 *************************************************/
const params = {
  // general scene params
  ...
+ // sun params
+ topColor: 0xffab00,
+ bottomColor: 0xff51c8
}
...
const lightIntensity2 = 0.85
// need to be even number since the consecutive terrains are stitched in pairs
const numOfMeshSets = 6
+ const sunPos = {
+   x: 0,
+   y: 16,
+   z: -100
+ }
+ const uniforms = {
+   ...getDefaultUniforms(),
+   color_main: { // sun's top color
+     value: hexToRgb("#ffab00", true)
+   },
+   color_accent: { // sun's bottom color
+     value: hexToRgb("#ff51c8", true)
+   }
+ }

...

let app = {
  async initScene() {
    ...

+   // the sun
+   const sunGeom = new THREE.SphereGeometry(30, 64, 64)
+   const sunMat = new THREE.ShaderMaterial({
+     uniforms: uniforms,
+     vertexShader: vertexShader(),
+     fragmentShader: fragmentShader(),
+     transparent: true
+   })
+   let sun = new THREE.Mesh(sunGeom, sunMat)
+   sun.position.set(sunPos.x, sunPos.y, sunPos.z)
+   scene.add(sun)

    // GUI controls
    const gui = new dat.GUI()
```

`uniforms`å˜é‡åŒ…å«è¦ä¼ é€’ç»™ç€è‰²å™¨ç¨‹åºçš„å‚æ•°ã€‚`fragmentShader()`ä¸­çš„åŠ¨ç”»ä»£ç ä¹Ÿåˆ©ç”¨äº†`getDefaultUniforms.`å®šä¹‰çš„`u_time``u_time`ç”±`runApp`ä¸­çš„åŠ¨ç”»å¾ªç¯æ›´æ–°ã€‚å¯¹äºä»»ä½•åŠ¨ç”»ä»£ç æ¥è¯´ï¼Œæ—¶é—´éƒ½æ˜¯å¿…ä¸å¯å°‘çš„å…ƒç´ ã€‚

åº”ç”¨ä»£ç æ›´æ”¹ä¼šç»™ä½ ä¸€ä¸ªåŠ¨ç”»å¤ªé˜³:

![](img/bc7f6c859e29893b8713c3f6695d7d9d.png)

# 9.æ·»åŠ  GUI æ§ä»¶ä»¥åœ¨è¿è¡Œæ—¶è°ƒæ•´å‚æ•°

GUI æ§ä»¶æœ‰åŠ©äºå¼€å‘äººå‘˜åœ¨è¿è¡Œæ—¶å¿«é€Ÿæµ‹è¯•å„ç§å‚æ•°å€¼ã€‚é€šå¸¸ï¼ŒGUI æ§ä»¶æ˜¯åœ¨å¼€å‘çš„æ—©æœŸé˜¶æ®µæ·»åŠ çš„ï¼Œä½†æ˜¯ä¸ºäº†æœ¬æ–‡çš„æµç¨‹ï¼Œæˆ‘å®æ„¿å…ˆè§£é‡Šæ‰€æœ‰é‡è¦çš„ä»£ç ã€‚

åœ¨`index.js`ä¸­è¿›è¡Œä»¥ä¸‹æ›´æ”¹:

```
 async initScene() {
    ...

    // GUI
    const gui = new dat.GUI()

+   gui.add(guiOptions, "speed", 1, 10, 0.5).name('Plane speed')
+   gui.addColor(guiOptions, 'dirLightColor1').name('Dir light 1').onChange((val) => {
+     this.dirLight1.color.set(val)
+   })
+   gui.addColor(guiOptions, 'dirLightColor2').name('Dir light 2').onChange((val) => {
+     this.dirLight2.color.set(val)
+   })

+   let planeFolder = gui.addFolder(`Plane`)
+   planeFolder.add(guiOptions, "metalness", 0, 1, 0.05).onChange((val) => {
+     meshMaterial.metalness = val
+   })
+   planeFolder.add(guiOptions, "roughness", 0, 1, 0.05).onChange((val) => {
+     meshMaterial.roughness = val
+   })
+   planeFolder.addColor(guiOptions, 'meshColor').name('color').onChange((val) => {
+     meshMaterial.color.set(val)
+   })
+   planeFolder.addColor(guiOptions, 'meshEmissive').name('emissive').onChange((val) => {
+     meshMaterial.emissive.set(val)
+   })
+   planeFolder.addColor(guiOptions, 'lineColor').name('line color').onChange((val) => {
+     lineMaterial.color.set(val)
+   })
+   planeFolder.add(guiOptions, "lineWidth", 0, 0.1, 0.01).name('line width').onChange((val) => {
+     lineMaterial.linewidth = val
+   })

+   let sunFolder = gui.addFolder(`Sun`)
+   sunFolder.addColor(guiOptions, 'topColor').name('top color').onChange((val) => {
+     let clr = new THREE.Color(val)
+     uniforms.color_main.value = hexToRgb(clr.getHexString(), true)
+   })
+   sunFolder.addColor(guiOptions, 'bottomColor').name('bottom color').onChange((val) => {
+     let clr = new THREE.Color(val)
+     uniforms.color_accent.value = hexToRgb(clr.getHexString(), true)
+   })

    // Stats - show fps
    this.stats1 = new Stats()
    this.stats1.showPanel(0) // Panel 0 = fps
    this.stats1.domElement.style.cssText = "position:absolute;top:0px;left:0px;"
    this.container.appendChild(this.stats1.domElement)
  },
```

ç°åœ¨ä½ å¯ä»¥ä»»æ„è°ƒæ•´å‚æ•°å’Œé¢œè‰²äº†ï¼

![](img/a905f23ff76152812edb7f7016331001.png)

# 10.ç”¨å¸ƒé²å§†æ•ˆæœâœ¨âœ¨å¯¹åœºæ™¯è¿›è¡ŒåæœŸå¤„ç†ï¼Œè®©å®ƒçœ‹èµ·æ¥æ›´é…·ï¼

ä¸‹é¢æ˜¯æœ¬æ–‡çš„æœ€åä¸€éƒ¨åˆ†ã€‚æˆ‘ä»¬å°†æ·»åŠ  Bloom æ•ˆæœæ¥ç…§äº®åœºæ™¯ï¼è¿™æœ€åçš„æ¶¦è‰²å¯¹äºè®©åœºæ™¯çœ‹èµ·æ¥å¾ˆé…·å’Œæ•£å‘å‡ºä¸€ç§åˆæˆæ³¢çš„æ°›å›´æ˜¯å¾ˆé‡è¦çš„ï¼

å¯¹`index.js`è¿›è¡Œä»¥ä¸‹æ›´æ”¹:

```
+ import { UnrealBloomPass } from "three/examples/jsm/postprocessing/UnrealBloomPass"

...

const params = {
  // general scene params
  speed: 2.5,
  dirLightColor1: 0x2dd7ff,
  dirLightColor2: 0x2dd7ff,
+ // bloom params
+ bloomStrength: 0.5,
+ bloomRadius: 0.2,
+ bloomThreshold: 0.5,
  // plane params
  metalness: 0.2,
  ...
}

...

// The RenderPass is already created in 'createComposer'
+ // Post-processing with Bloom effect
+ let bloomPass = new UnrealBloomPass(
+   new THREE.Vector2(window.innerWidth, window.innerHeight),
+   params.bloomStrength,
+   params.bloomRadius,
+   params.bloomThreshold
+ );
let composer = createComposer(renderer, scene, camera, (comp) => {
+   comp.addPass(bloomPass)
})

...

let app = {
  async initScene() {
  ...

    // GUI controls
    const gui = new dat.GUI()

+   let bloomFolder = gui.addFolder(`Bloom`)
+   bloomFolder.add(params, "bloomStrength", 0, 3, 0.05).onChange((val) => {
+     bloomPass.strength = Number(val)
+   })
+   bloomFolder.add(params, "bloomRadius", 0, 1, 0.05).onChange((val) => {
+     bloomPass.radius = Number(val)
+   })
+   bloomFolder.add(params, "bloomThreshold", 0, 1, 0.05).onChange((val) => {
+     bloomPass.threshold = Number(val)
+   })
```

è¿™éœ€è¦ä¸€äº›å®éªŒæ¥è·å¾—é€‚åˆåœºæ™¯çš„é«˜å…‰å‚æ•°ã€‚éšç€è¿™æœ€åçš„æ¶¦è‰²åˆ°ä½ï¼Œæ•´ä¸ªåœºæ™¯ç°åœ¨ç…§äº®äº†âœ¨:

![](img/ea9ede7e6c89eaf532b54f0581d39253.png)

ä¸€æ—¦ä½ å¼€èŠ±äº†ï¼Œå°±å†ä¹Ÿä¸ä¼šå›æ¥äº†ã€‚

è¿™å°±æ˜¯äº†ã€‚æ‚¨å·²ç»å®Œæˆäº†æ•™ç¨‹ï¼

è¯´å®è¯ï¼Œåœ¨åŠ¨ç¬”ä¹‹å‰ï¼Œæˆ‘å·²ç»æ­å»ºäº†ä¸€ä¸ªæˆ‘è®¤ä¸ºè¶³å¤Ÿå¥½çš„ç‰ˆæœ¬ã€‚ç„¶è€Œï¼Œå½“æˆ‘å¼€å§‹å†™è¿™ç¯‡æ–‡ç« æ—¶ï¼Œæˆ‘å‘ç°å®ƒå¹¶ä¸å¥½ï¼

æˆ‘æ­£åœ¨ä½¿ç”¨ä¸€ä¸ªå¤æ‚çš„è‡ªå®šä¹‰`BufferGeometry`æ„å»ºåœ°å½¢å‡ ä½•å›¾å½¢ã€‚è§†è§‰æ•ˆæœå’Œæ€§èƒ½æ¯”æˆ‘ç°åœ¨å¾—åˆ°çš„ç»“æœæ›´å·®ã€‚æ„Ÿè°¢é˜…è¯»ã€‚