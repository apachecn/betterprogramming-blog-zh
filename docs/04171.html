<html>
<head>
<title>Publish a JavaScript Package to NPM Automatically With Github Actions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Github动作自动发布一个JavaScript包到NPM</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-publish-a-javascript-package-to-npm-automatically-with-github-actions-1acde7b908d6?source=collection_archive---------7-----------------------#2020-03-27">https://betterprogramming.pub/how-to-publish-a-javascript-package-to-npm-automatically-with-github-actions-1acde7b908d6?source=collection_archive---------7-----------------------#2020-03-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="137d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">维护开源包可能是一项耗时的任务</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4de36066a8460fe61215920728c79060.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r6KN06y5ufaWCavpGnmPVQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">阿里夫·瓦希德在<a class="ae kv" href="https://unsplash.com/s/photos/future?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="0baf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">维护开源包可能是一项耗时的任务。有问题要分类，有拉请求要审查，有变更日志要写。发布新版本的代码通常是手工完成的，自动化通常被放在维护者的待办事项列表的次要位置。</p><p id="7ef1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个坚如磐石的发布过程有几个关键特征，即<a class="ae kv" href="https://www.techopedia.com/definition/13934/changelog" rel="noopener ugc nofollow" target="_blank">变更日志</a>、<a class="ae kv" href="https://git-scm.com/book/en/v2/Git-Basics-Tagging" rel="noopener ugc nofollow" target="_blank"> Git标签</a>、<a class="ae kv" href="https://stackoverflow.com/questions/10972176/find-the-version-of-an-installed-npm-package" rel="noopener ugc nofollow" target="_blank"> NPM版本</a>，以及强制<a class="ae kv" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank">语义版本</a>。使所有这些保持同步，这样用户就能了解一个版本中的变化，并了解如何保持最新。未能执行所有这些步骤的维护人员将很难对问题进行分类，这导致花费更多的时间进行调试，而花费更少的时间进行编码。</p><p id="12c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我最近遇到了一个工具组合，<a class="ae kv" href="https://github.com/semantic-release/semantic-release" rel="noopener ugc nofollow" target="_blank">语义发布</a>和<a class="ae kv" href="https://github.com/features/actions" rel="noopener ugc nofollow" target="_blank"> Github动作</a>，它们使得整个发布过程自动化、透明、简单易懂。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="b8a3" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">它是如何工作的</h1><p id="dc00" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在我们讨论实现之前，理解我们的工具将执行什么工作是很重要的。这样，如果有问题或修改，我们可以修复它们。将完成这里的大部分工作——他们在自述文件中说得最清楚。</p><blockquote class="na nb nc"><p id="39f9" class="kw kx nd ky b kz la jr lb lc ld ju le ne lg lh li nf lk ll lm ng lo lp lq lr ij bi translated">它自动化了整个包发布工作流，包括确定下一个版本号、生成发布说明和发布包。</p></blockquote><h2 id="f404" class="nh ma iq bd mb ni nj dn mf nk nl dp mj lf nm nn ml lj no np mn ln nq nr mp ns bi translated">下一个版本号</h2><p id="2b56" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在发布时，为了确定下一个版本号，该工具读取自上一个发布以来的提交，它通过查看您的Git标记来定位。基于提交的类型，它可以决定如何提升包的版本。要做到这一点，提交需要以某种方式编写。</p><p id="58ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">默认情况下，语义发布使用<a class="ae kv" href="https://github.com/angular/angular.js/blob/master/DEVELOPERS.md#-git-commit-guidelines" rel="noopener ugc nofollow" target="_blank">角度提交消息约定</a>。这一点很关键，因为软件包的消费者需要知道新版本是否发布了新特性，是否引入了突破性的变化，或者两者都有。例如，如果有人提交了<code class="fe mw mx my mz b">fix(pencil): stop graphite breaking when too much pressure applied</code>，semantic-release知道这包含一个修复，它必须创建一个补丁发布。这将增加次要版本范围(0.0.x)中的版本。</p><p id="c7d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以前从未见过这种版本控制？ <a class="ae kv" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank"> <em class="nd">检出语义版本</em> </a> <em class="nd">。</em></p><p id="df6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在分析了所有的提交之后，它会选择优先级最高的变更类型，并确保应用的是那个类型。例如，如果自上一个版本以来引入了两个提交，一个是中断(x.0.0)，一个是次要的(0.0.x)，它会知道通过中断范围来升级版本。</p><h2 id="bc22" class="nh ma iq bd mb ni nj dn mf nk nl dp mj lf nm nn ml lj no np mn ln nq nr mp ns bi translated">生成发行说明</h2><p id="7186" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">一旦发现下一个版本是什么类型的版本，就会基于提交生成changelog注释。<code class="fe mw mx my mz b">semantic-release</code>不使用传统的<code class="fe mw mx my mz b">CHANGELOG.md</code>文件来通知用户发生了什么变化，而是使用附加在Git标签上的<a class="ae kv" href="https://help.github.com/en/github/administering-a-repository/about-releases" rel="noopener ugc nofollow" target="_blank"> Github版本</a>来通知用户。</p><p id="05bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里是一个Github版本的例子，语义发布生成并推进构建。</p><h2 id="1683" class="nh ma iq bd mb ni nj dn mf nk nl dp mj lf nm nn ml lj no np mn ln nq nr mp ns bi translated">Github动作自动化</h2><p id="bbcd" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><code class="fe mw mx my mz b">semantic-release</code>是执行大部分工作的工具，但是我们仍然需要一个服务来运行这个工具。这就是<a class="ae kv" href="https://github.com/features/actions" rel="noopener ugc nofollow" target="_blank"> Github Actions </a>发挥作用的地方。当pull-requests合并到master(或您配置的任何基本分支)中时，Github Actions将运行一个作业，该作业只运行您配置的语义发布。我们之前描述的所有工作都将被执行。</p><p id="04af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有一个Github操作的例子，使用语义发布来发布一个新版本。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="0f3e" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">要采取的步骤</h1><p id="d19d" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们将使用尽可能多的默认值来使配置变得非常简单。使用插件系统来增强功能。<a class="ae kv" href="https://github.com/semantic-release/semantic-release/blob/master/docs/usage/plugins.md#default-plugins" rel="noopener ugc nofollow" target="_blank">以下是语义发布使用的默认插件。</a></p><p id="5094" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来回顾一下这些步骤，以使这一切顺利进行。</p><p id="c327" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 1。</strong>在package的package.json中添加一个虚拟版本属性。发布的代码将由<code class="fe mw mx my mz b">semantic-release</code>将正确的版本写入该文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">新package.json中的version属性</p></figure><p id="a919" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 2。</strong>添加一个新的属性到package.json，<code class="fe mw mx my mz b">publishConfig</code>——这将是我们语义发布配置的家。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">新package.json中的publishConfig属性</p></figure><p id="6fba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 3。</strong>最后一步是创建一个Github动作YAML文件。这将告诉Github Actions在提交存储库时做什么。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Github操作配置文件</p></figure><p id="5ce3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 4。</strong>将<code class="fe mw mx my mz b">NPM_TOKEN</code>添加到Github repos设置页面的秘密中。您可以从您的NPM账户:<code class="fe mw mx my mz b">https://www.npmjs.com/settings/&lt;username&gt;/tokens</code>生成其中一个</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/15997cd829a60572632a6fde7e43fbdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nHdr_94qjK_KjrcpzSu3rQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">秘密藏在哪里</p></figure><p id="7127" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样！您现在拥有了一个完全自动化的包发布过程！</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="1255" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">奖金</h1><p id="fd8c" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我在我们最近在Yolk AI开源的一个回购上实现了这个。它被命名为<a class="ae kv" href="https://github.com/Yolk-HQ/next-utils" rel="noopener ugc nofollow" target="_blank"> next-utils </a>，这里描述的一切都可以在那里找到。</p><p id="c3bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将semantic-release与Github Actions结合使用的另一个好处是，它支持即时可用的bot注释。它将深入到自上次发布和评论以来关闭的每个问题和拉动式请求，以确保每个人都知道。这里有一个例子。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/169853f38958fb47687379fd798e4d07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HZo2zWyv79qIzc3ejycRnA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">github-actions bot对github问题的评论示例</p></figure></div></div>    
</body>
</html>