# è°·æ­Œæœ‰ä¸€ä¸ªåä¸º Foobar çš„ç§˜å¯†æ‹›è˜æŒ‘æˆ˜

> åŸæ–‡ï¼š<https://betterprogramming.pub/google-has-a-secret-hiring-challenge-called-foobar-14625bfcea7a>

## ä»¥ä¸‹æ˜¯æˆ‘æ˜¯å¦‚ä½•è¿›å…¥çš„ï¼Œä»¥åŠä¸ºä»€ä¹ˆæˆ‘å–œæ¬¢è¿™äº›é—®é¢˜

![](img/f651578eedab5b6d8d48291547286f9a.png)

Google Foobar é‚€è¯·æ¶ˆæ¯

è¿™ç¯‡æ–‡ç« æ¦‚è¿°äº†æˆ‘ä½¿ç”¨ Google Foobar çš„ç»å†:æˆ‘å¦‚ä½•è·å¾—é‚€è¯·ï¼Œé—®é¢˜ï¼Œæˆ‘çš„æäº¤ï¼Œä»¥åŠä¹‹åå‘ç”Ÿäº†ä»€ä¹ˆã€‚è¯·æ³¨æ„ï¼Œè¿™ç¯‡æ–‡ç« åŒ…å«å¤§é‡çš„å‰§é€ã€‚

# ä»‹ç»

æˆ‘ç¬¬ä¸€æ¬¡è¯»åˆ° Google çš„ Foobar challenge ä¸€å®šæ˜¯åœ¨ 2019 å¹´çš„æŸä¸ªæ—¶å€™ã€‚æˆ‘å¶å°”ä¼šä¸Š Codewarsï¼Œå–œæ¬¢è§£å†³ç®—æ³•é—®é¢˜ï¼Œæ‰€ä»¥å½“æˆ‘è¯»åˆ° Foobar æ—¶ï¼Œæˆ‘æƒ³è¯•ä¸€è¯•ã€‚ä½†é¦–å…ˆï¼Œè®©æˆ‘ä»¬é€€ä¸€æ­¥ï¼Œæ€»ç»“ä¸€ä¸‹ Foobar æ˜¯ä»€ä¹ˆã€‚

# ä»€ä¹ˆæ˜¯ Foobarï¼Ÿ

Foobar æ˜¯ä¸€ä¸ªåŠç§˜å¯†çš„æ‹›è˜æŒ‘æˆ˜ï¼Œè°·æ­Œé€šè¿‡ä¸€äº›éä¼ ç»Ÿä½†åˆé€‚çš„æ–¹å¼æ¥å¯»æ‰¾æœ‰æ‰åçš„å¼€å‘äººå‘˜ã€‚Foobar æ˜¯ä¸€ç³»åˆ—**äº”ä¸ªçº§åˆ«çš„ç®—æ³•é—®é¢˜**ï¼Œéš¾åº¦ä¸æ–­å¢åŠ ï¼Œå¹¶åˆ†é…æ—¶é—´æ¥è§£å†³è¿™äº›é—®é¢˜ã€‚ä¸€æ—¦å¼€å‘äººå‘˜æå‡ºé—®é¢˜ï¼Œæ—¶é—´å°±å¼€å§‹è®¡æ—¶ã€‚

*   **ç¬¬ä¸€å…³:**ä¸€ä¸ªé—®é¢˜â€”â€”48 å°æ—¶
*   **ç¬¬äºŒçº§:**ä¸¤ä¸ªé—®é¢˜â€”â€”æ¯ä¸ªé—®é¢˜ 72 å°æ—¶
*   **ç¬¬ä¸‰çº§:**ä¸‰ä¸ªé—®é¢˜â€”æ¯ä¸ªé—®é¢˜ 7 å¤©
*   **ç¬¬ 4 çº§:**ä¸¤ä¸ªé—®é¢˜â€”æ¯ä¸ªé—®é¢˜ 2 å‘¨
*   **ç¬¬ 5 çº§:**ä¸€ä¸ªé—®é¢˜â€” 22 å¤©

å¯¹äºæ¯ä¸ªé—®é¢˜ï¼Œä½ å¯ä»¥æäº¤ç”¨ Python (2.7)æˆ– Java ç¼–å†™çš„è§£å†³æ–¹æ¡ˆã€‚åœ¨æäº¤ä¹‹å‰ï¼Œæ‚¨è¿˜å¯ä»¥éªŒè¯æ‚¨çš„è§£å†³æ–¹æ¡ˆï¼Œå¹¶å¯¹å…¶è¿›è¡Œä¸€ç³»åˆ—ç§˜å¯†æµ‹è¯•ã€‚ç„¶è€Œï¼Œåªæœ‰å½“ä½ çš„ç®—æ³•é€šè¿‡æˆ–è€…æ²¡æœ‰é€šè¿‡æµ‹è¯•æ—¶ï¼Œä½ æ‰è¢«å‘ŠçŸ¥æµ‹è¯•ç”¨ä¾‹ã€‚

Foobar çš„é…·ä¹‹å¤„åœ¨äºå®ƒå‘ç”Ÿåœ¨ä¸€ä¸ªè™šæ‹ŸæœåŠ¡å™¨ä¸Šï¼Œä¸€æ—¦ä½ è¢«é‚€è¯·å‚åŠ æŒ‘æˆ˜ï¼Œä½ å°±å¯ä»¥è®¿é—®è¿™ä¸ªè™šæ‹ŸæœåŠ¡å™¨ã€‚

![](img/d8c31cd31c31e625a8d51ffe6386d381.png)

Foobar:å¯ç”¨å‘½ä»¤

è¿™ä¸ªåœºæ™¯è®¾ç½®åœ¨ä¸€è‰˜ç”±æŒ‡æŒ¥å®˜ Lambda é©¾é©¶çš„è™šæ‹Ÿé£èˆ¹ä¸­ï¼ŒLambda æ˜¯ä¸€ä¸ªéå¸¸åˆ»è–„çš„æœå¾·ç‰¹äººã€‚Lambda æŒ‡æŒ¥å®˜æ•è·äº†ä¸€ç¾¤å¤ªç©ºå…”å­ï¼Œä½ çš„ä»»åŠ¡æ˜¯è¥æ•‘å®ƒä»¬ã€‚

## å¦‚ä½•è¿›å…¥ Foobarï¼Ÿ

å…³äº Foobar æœ€æœ‰è¶£çš„éƒ¨åˆ†æ˜¯è¿›å…¥ã€‚æœ‰ä¸¤ç§è¿›å…¥æ–¹å¼:ä¸€ç§æ˜¯ä¸Šç½‘æ—¶ç›´æ¥è¢«è°·æ­Œé‚€è¯·ï¼Œå¦ä¸€ç§æ˜¯é€šè¿‡é‚€è¯·ç ã€‚

## A.ç›´æ¥é‚€è¯·

è¿™ç§è¿›å…¥ Foobar çš„æ–¹å¼è¦é…·å¾—å¤šï¼Œå› ä¸ºå®ƒé€šå¸¸ä¼šè®©æ¥æ”¶è€…æªæ‰‹ä¸åŠã€‚é€šå¸¸ä¼šå‘ç”Ÿçš„æ˜¯ï¼Œä¸€ä¸ªäººä¸€ç›´åœ¨è°·æ­Œæœç´¢(é«˜çº§)è½¯ä»¶å·¥ç¨‹ä¸»é¢˜ã€‚ä¸€æ—¦è°·æ­Œè¶³å¤Ÿè‡ªä¿¡åœ°è®¤ä¸ºè¿™ä¸ªäººçŸ¥é“ä»–ä»¬åœ¨æ‰¾ä»€ä¹ˆï¼Œæœç´¢æ å°±ä¼šæ‰“å¼€ï¼Œä¸€ä¸ªæŒ‘æˆ˜å°±å‡ºç°äº†ã€‚

## **B .é‚€è¯·é“¾æ¥**

è°·æ­Œ Foobar æŒ‘æˆ˜èµ›çš„æ‰€æœ‰å‚ä¸è€…åœ¨å®Œæˆç¬¬ 3 çº§å’Œç¬¬ 5 çº§åéƒ½ä¼šè·å¾—ä¸€ä¸ªä¸ªäººé‚€è¯·é“¾æ¥ã€‚å‚ä¸è€…å¯ä»¥ä½¿ç”¨é‚€è¯·é“¾æ¥æ¥é‚€è¯·æœ‹å‹/åŒäº‹ã€‚

## é‚£ä¹ˆæˆ‘æ˜¯æ€ä¹ˆè¿›å…¥ Foobar çš„å‘¢ï¼Ÿ

2019 å¹´çš„æŸä¸ªæ—¶å€™ï¼Œåœ¨ç¬¬ä¸€æ¬¡è¯»åˆ° Foobar ä¹‹åï¼Œæˆ‘è¯•å›¾è°·æ­Œæœ€æ™¦æ¶©çš„æŠ€æœ¯é—®é¢˜ï¼Œç›®çš„æ˜¯è§¦å‘é‚€è¯·ã€‚é‚£æ²¡ç”¨ã€‚ä»€ä¹ˆéƒ½æ²¡å‘ç”Ÿã€‚æ‰€ä»¥æˆ‘å·®ä¸å¤šæŠŠå®ƒå¿˜äº†ï¼Œç›´åˆ°å¤§çº¦ä¸€å¹´å‰ï¼Œæˆ‘åœ¨ç ”ç©¶ä¸‹é¢è¿™ç¯‡æ–‡ç« :

[](https://towardsdatascience.com/reimplementing-popular-python-functionalities-in-javascript-b3cfe8e7849f) [## ç”¨ JavaScript é‡æ–°å®ç°æµè¡Œçš„ Python åŠŸèƒ½

### å­¦ä¹ å¦‚ä½•åœ¨æ–°çš„ä¸–ç•Œä¸­åº”å¯¹ï¼Œå¹¶å……åˆ†åˆ©ç”¨ç°æœ‰çš„å·¥å…·ã€‚

towardsdatascience.com](https://towardsdatascience.com/reimplementing-popular-python-functionalities-in-javascript-b3cfe8e7849f) 

å½“æœç´¢æ æ‰“å¼€æ—¶ï¼Œæœ‰äººé—®æˆ‘æ˜¯å¦å‡†å¤‡å¥½æ¥å—æŒ‘æˆ˜ï¼Œæˆ‘å¾ˆæ¸…æ¥šä¼šå‘ç”Ÿä»€ä¹ˆï¼Œç„¶åç‚¹äº†â€œæ˜¯â€ã€‚ä»¤äººå°´å°¬çš„æ˜¯ï¼Œå½“æ—¶æˆ‘ä¸»è¦æ˜¯åœ¨è°·æ­Œä¸Šæœç´¢åƒ`list comprehension`å’Œ`dictionary comprehension`è¿™æ ·çš„ä¸œè¥¿ã€‚

# é—®é¢˜

**âš ï¸è­¦å‘Šâš ï¸** ä»¥ä¸‹éƒ¨åˆ†åŒ…å«äº†æˆ‘åœ¨æ•´ä¸ªå…³å¡æ—…é€”ä¸­é‡åˆ°çš„é—®é¢˜ã€‚æˆ‘è€ƒè™‘ä¸å‘è¡¨è¿™ç¯‡æ–‡ç« ï¼Œå› ä¸ºæˆ‘ä¸æƒ³å…¬å¼€è§£å†³æ–¹æ¡ˆè€Œâ€œç ´åâ€è¿™ä¸ªæŒ‘æˆ˜ã€‚ç„¶è€Œï¼Œä»–ä»¬æ— è®ºå¦‚ä½•ã€‚ä¸€äº›äººå·²ç»å†™äº†å…³äºè¿™äº›é—®é¢˜çš„æ–‡ç« ï¼Œå¹¶ä¸”å¯ä»¥åœ¨äº’è”ç½‘ä¸Šæ‰¾åˆ°è§£å†³æ–¹æ¡ˆã€‚æ­¤å¤–ï¼Œæˆ‘åœ¨è§£å†³é—®é¢˜çš„è¿‡ç¨‹ä¸­è·å¾—äº†å¾ˆå¤šä¹è¶£ï¼Œå¹¶æ„è¯†åˆ°ä¸€äº›ç®—æ³•å®é™…ä¸Šå¯ä»¥åº”ç”¨äºæˆ‘ä»¥å‰é‡åˆ°çš„ç°å®ç”Ÿæ´»ä¸­çš„é—®é¢˜ã€‚æ‰€ä»¥æˆ‘è§‰å¾—è¿™äº›æŒ‘æˆ˜ä¸ä»…å¾ˆæœ‰è¶£ï¼Œè€Œä¸”å¾ˆæœ‰å¯å‘æ€§ã€‚

ä½ å¯ä»¥åœ¨è¿™é‡Œæ‰¾åˆ°é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ[ã€‚åœ¨æ¥ä¸‹æ¥çš„éƒ¨åˆ†ä¸­ï¼Œæˆ‘å°†æè¿°æˆ‘çš„æ€ç»´è¿‡ç¨‹å’Œå¯¹æ¯ä¸ªé—®é¢˜çš„å®é™…åº”ç”¨çš„ä½¿ç”¨ã€‚](https://github.com/FBosler/GoogleFoobar/blob/main/Readme.md)

## é—®é¢˜ 1ã€‚

ç¬¬ä¸€ä¸ªé—®é¢˜è¦æ±‚æ‚¨æ‰§è¡Œä»¥ä¸‹æ“ä½œ:

```
**Problem:**Write a function called solution(data, n) that takes in a list of less than 100 integers and a number n, and returns that same list but with all of the numbers that occur more than n times removed entirely
```

è¿™ä¸ªé—®é¢˜èŠ±äº†å‡ åˆ†é’Ÿæ‰å¼„æ˜ç™½ï¼Œè€Œä¸”è¿™ä¸ªé—®é¢˜å¹¶æ²¡æœ‰çœŸæ­£è¿«ä½¿æˆ‘å»å­¦ä¹ ä¸€äº›ç‰¹åˆ«æ–°çš„ä¸œè¥¿:

```
**Solution:**from collections import Counter

def solution(data, n):
    counted = Counter(data)
    return [k for k, v in counted.items() if v <= n]
```

æˆ‘ä»¬å¯ä»¥åˆ©ç”¨`collections.Counter`æ‰¾åˆ°è§£å†³åŠæ³•ã€‚æˆ‘çš„å®é™…æäº¤æ•ˆç‡æ›´ä½ï¼Œå› ä¸ºæˆ‘æ£€æŸ¥äº†`v>n`ï¼Œç„¶åå†æ¬¡å¾ªç¯æ•°æ®ã€‚ä¸çŸ¥é“ä¸ºä»€ä¹ˆğŸ¤·â€â™‚ï¸.

## é—®é¢˜ 2aã€‚

```
**Problem:**Given a non-empty list of positive integers l and a target positive integer t, write a function solution(l, t) which verifies if there is at least one consecutive sequence of positive integers within the list l (i.e. a contiguous sub-list) that can be summed up to the given target positive integer t (the key) and returns the lexicographically smallest list containing the smallest start and end indexes where this sequence can be found, or returns the array [-1, -1] in the case that there is no such sequence (to throw off Lambda's spies, not all number broadcasts will contain a coded message).
```

æœ‰æ„æ€ï¼Œä½†æ˜¯è§£å†³èµ·æ¥ä¸å¤ªå¤æ‚(æˆ‘è§‰å¾—)ã€‚æˆ‘éå†äº†è¿™äº›å€¼ï¼Œå¹¶æ£€æŸ¥äº†æ¯ä¸ªå€¼æ˜¯å¦æœ‰ä¸€ä¸ªä»¥åŠ èµ·æ¥ç­‰äº`t`çš„å€¼å¼€å§‹çš„å­åˆ—è¡¨ã€‚å¤æ‚æ€§åœ¨æœ€åçš„æƒ…å†µä¸‹å¤§çº¦åœ¨`(n^2)/2 â€” n/2`å·¦å³ï¼Œè¿™å½“ç„¶ä¸æ˜¯å¾ˆå¥½ï¼Œä½†æ˜¯æˆ‘ä¸è§‰å¾—æ€§èƒ½æ˜¯ä¸ªé—®é¢˜ï¼Œæ‰€ä»¥æˆ‘è®©å®ƒä¿æŒåŸæ ·ã€‚åœ¨æ­¤æ‰¾åˆ°å®Œæ•´çš„é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ[ã€‚](https://github.com/FBosler/GoogleFoobar/tree/main/problem_2/a)

## é—®é¢˜ 2bã€‚

```
**Problem:**Oh no! Commander Lambda's latest experiment to improve the efficiency of her LAMBCHOP doomsday device has backfired spectacularly. She had been improving the structure of the ion flux converter tree, but something went terribly wrong and the flux chains exploded. Some of the ion flux converters survived the explosion intact, but others had their position labels blasted off. She's having her henchmen rebuild the ion flux converter tree by hand, but you think you can do it much more quickly - quickly enough, perhaps, to earn a promotion!

Flux chains require perfect binary trees, so Lambda's design arranged the ion flux converters to form one. To label them, she performed a post-order traversal of the tree of converters and labeled each converter with the order of that converter in the traversal, starting at 1\. For example, a tree of 7 converters would look like the following:

```
   7
 3   6
1 2 4 5
```Write a function solution(h, q) - where h is the height of the perfect tree of converters and q is a list of positive integers representing different flux converters - which returns a list of integers p where each element in p is the label of the converter that sits on top of the respective converter in q, or -1 if there is no such converter.  For example, solution(3, [1, 4, 7]) would return the converters above the converters at indexes 1, 4, and 7 in a perfect binary tree of height 3, which is [3, 6, -1].
```

è¿™æ˜¯æˆ‘çœŸæ­£å–œæ¬¢çš„ç¬¬ä¸€ä¸ªé—®é¢˜ï¼Œå› ä¸ºå®ƒè®©æˆ‘æ€è€ƒè¿™æ ·çš„æ ‘å°†å¦‚ä½•æ¦‚æ‹¬ï¼Œä»¥åŠå“ªäº›ä¿¡æ¯å°†æ˜¯å¯ç”¨çš„å’Œå®¹æ˜“è®¡ç®—çš„ã€‚

å¯¹äºé«˜åº¦ä¸º`h`çš„æ ‘ï¼Œæˆ‘ä»¬é¦–å…ˆéœ€è¦æ‰¾åˆ°çš„æ˜¯æ ¹èŠ‚ç‚¹çš„å€¼ï¼Œä¹Ÿå°±æ˜¯æ ‘ä¸­å€¼çš„æ•°é‡ï¼Œæ¢å¥è¯è¯´:

`base_root = sum([2 ** level for level in range(h)])`

æˆ‘ä»¬éœ€è¦ä¸€ä¸ªå‡½æ•°ï¼Œå®ƒèƒ½ä¸ºæ¯ä¸ªç»™å®šçš„æ•°æ‰¾åˆ°æ ¹ã€‚è¿™ä¸ªå‡½æ•°éœ€è¦æˆ‘ä»¬çš„`base_root`æ ‘çš„`height`å’Œ`element`æ¥æ£€æŸ¥ã€‚è¿™ä¸ªå‡½æ•°å°†ä¼šå·¥ä½œã€‚

1.  æ£€æŸ¥æˆ‘ä»¬æ˜¯å¦è¶Šç•Œ(å³é¡¶éƒ¨æ²¡æœ‰èŠ‚ç‚¹)`-> -1`
2.  è®¡ç®—`left_leaf = root_value â€” 2**(height-1)`å’Œ`right_leaf = root_value -1`
3.  æ£€æŸ¥`element not in [left_leaf, right_leaf]`å’Œ`else -> root_value`
4.  ç°åœ¨ï¼Œè™½ç„¶`element`ä¸æ˜¯è¿™ä¸¤ç‰‡å¶å­ä¸­çš„ä»»ä½•ä¸€ç‰‡ï¼Œä½†æˆ‘ä»¬éå†äº†å…ƒç´ æ‰€åœ¨çš„æ ‘æ(æœ‰ç‚¹åƒäºŒåˆ†æœç´¢æ³•)ã€‚å¦‚æœ`element`å°äº`left_leaf`ï¼Œé‚£ä¹ˆå®ƒå°†ä½äºæ ‘çš„å·¦ä¾§ï¼›å¦åˆ™ï¼Œåœ¨æ ‘çš„å³è¾¹ã€‚
5.  å°†`root_value`è®¾ç½®ä¸º`left_leaf`æˆ–`right_leaf`å¹¶å°†é«˜åº¦é™ä½ä¸€ã€‚
6.  å†²æ´—å¹¶é‡å¤ã€‚æˆ‘ä»¬å¯ä»¥é€’å½’åœ°æˆ–è€…ä½¿ç”¨ while å¾ªç¯æ¥å®ç°ã€‚

ä½ å¯ä»¥åœ¨è¿™é‡Œæ‰¾åˆ°å®Œæ•´çš„é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆã€‚

## é—®é¢˜ 3aã€‚

è¿™æ˜¯ä¸€ä¸ªçœŸæ­£çš„æŒ‡ç”²å’¬ã€‚ä½†ä¹Ÿæ˜¯æˆ‘æœ€å–œæ¬¢çš„ç¬¬ä¸€ä¸ªï¼Œå› ä¸ºå®ƒè®©æˆ‘é‡æ–°ç ”ç©¶äº†é©¬å°”å¯å¤«é“¾ã€‚æ­¤å¤–ï¼Œåœ¨ç ”ç©¶è¿™ä¸ªé—®é¢˜æ—¶ï¼Œæˆ‘æ„è¯†åˆ°æˆ‘é‡åˆ°äº†ä¸€äº›ç°å®ç”Ÿæ´»ä¸­çš„åº”ç”¨ï¼Œè¿™äº›ç†è®ºå¯èƒ½ä¼šæœ‰æ‰€å¸®åŠ©ã€‚ç¬¬ä¸€ä¸ªæƒ³åˆ°çš„æ˜¯å®¢æˆ·ç»ˆèº«ä»·å€¼ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå®¢æˆ·å¯ä»¥ä»ä¸€ä¸ªç»†åˆ†å¸‚åœºè½¬ç§»åˆ°å¦ä¸€ä¸ªç»†åˆ†å¸‚åœºï¼Œè¿™ç§è½¬ç§»å¯ä»¥æ˜¯éšæ€§çš„(å¦‚ä»–ä»¬çš„è´­ä¹°è¡Œä¸ºæ‰€ç¤º)ï¼Œä¹Ÿå¯ä»¥æ˜¯æ˜¾æ€§çš„(å¦‚è®¢é˜…è®¡åˆ’çš„å˜åŒ–æ‰€ç¤º)ã€‚

ç°åœ¨ï¼Œå¦‚æœä¸€ä¸ªäººå¯ä»¥è®¡ç®—æ–°å®¢æˆ·çš„é¢„æœŸç»ˆç«¯åˆ†å¸ƒ(åœ¨ç»†åˆ†å¸‚åœºä¸Š),å¹¶ä¸”å¦‚æœä¸€ä¸ªäººçŸ¥é“æŸä¸ªç‰¹å®šç»†åˆ†å¸‚åœºä¸­æŸä¸ªå®¢æˆ·çš„å¤§æ¦‚ç»ˆèº«ä»·å€¼ï¼Œé‚£ä¹ˆä»–å°±å¯ä»¥éå¸¸å‡†ç¡®åœ°ä¼°è®¡éšæœºæ–°å®¢æˆ·çš„ç»ˆèº«ä»·å€¼ã€‚

ä¸ç®¡æ€æ ·ï¼Œè®©æˆ‘ä»¬è½¬ç§»åˆ°é—®é¢˜ä¸Šæ¥:

```
**Problem:**Making fuel for the LAMBCHOP's reactor core is a tricky process because of the exotic matter involved. It starts as raw ore, then during processing, begins randomly changing between forms, eventually reaching a stable form. There may be multiple stable forms that a sample could ultimately reach, not all of which are useful as fuel. 

Commander Lambda has tasked you to help the scientists increase fuel creation efficiency by predicting the end state of a given ore sample. You have carefully studied the different structures that the ore can take and which transitions it undergoes. It appears that, while random, the probability of each structure transforming is fixed. That is, each time the ore is in 1 state, it has the same probabilities of entering the next state (which might be the same state).  You have recorded the observed transitions in a matrix. The others in the lab have hypothesized more exotic forms that the ore can become, but you haven't seen all of them.

Write a function solution(m) that takes an array of array of nonnegative ints representing how many times that state has gone to the next state and return an array of ints for each terminal state giving the exact probabilities of each terminal state, represented as the numerator for each state, then the denominator for all of them at the end and in simplest form. The matrix is at most 10 by 10\. It is guaranteed that no matter which state the ore is in, there is a path from that state to a terminal state. That is, the processing will always eventually end in a stable state. The ore starts in state 0\. The denominator will fit within a signed 32-bit integer during the calculation, as long as the fraction is simplified regularly. 

For example, consider the matrix m:
```
[
  [0,1,0,0,0,1],  # s0, the initial state, goes to s1 and s5 with equal probability
  [4,0,0,3,2,0],  # s1 can become s0, s3, or s4, but with different probabilities
  [0,0,0,0,0,0],  # s2 is terminal, and unreachable (never observed in practice)
  [0,0,0,0,0,0],  # s3 is terminal
  [0,0,0,0,0,0],  # s4 is terminal
  [0,0,0,0,0,0],  # s5 is terminal
]
```
So, we can consider different paths to terminal states, such as:
```
s0 -> s1 -> s3
s0 -> s1 -> s0 -> s1 -> s0 -> s1 -> s4
s0 -> s1 -> s0 -> s5
```
Tracing the probabilities of each, we find that
s2 has probability 0
s3 has probability 3/14
s4 has probability 1/7
s5 has probability 9/14
So, putting that together, and making a common denominator, gives an answer in the form of
```
[s2.numerator, s3.numerator, s4.numerator, s5.numerator, denominator] which is
[0, 3, 2, 9, 14].
```
```

æˆ‘ä»¬å®é™…ä¸Šéœ€è¦ç›¸å½“å¤šçš„çº¿æ€§ä»£æ•°æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬å¿…é¡»è‡ªå·±å®ç°ï¼Œå› ä¸ºæ ‡å‡† Python 2.7 åº“ä¸­æ²¡æœ‰çº¿æ€§ä»£æ•°ã€‚æ‚¨å¯ä»¥åœ¨å›è´­ä¸­æ‰¾åˆ°å®Œæ•´çš„è§£å†³æ–¹æ¡ˆï¼Œä½†æˆ‘å°†åœ¨è¾ƒé«˜çš„å±‚æ¬¡ä¸Šä»‹ç»è¿™äº›æ­¥éª¤ã€‚ä¸è¿‡ï¼Œé¦–å…ˆï¼Œä½ åº”è¯¥çœ‹çœ‹è¾¾ç‰¹èŒ…æ–¯çš„è¿™ä¸ª[ç²¾å½©è®²åº§çš„ç¬¬ 11.2 ç« (426 é¡µèµ·)ï¼Œåœ¨é‚£é‡Œæ‰€æœ‰çš„ç†è®ºåŸºç¡€åŠå…¶è¦æ±‚éƒ½å¾—åˆ°äº†å¾ˆå¥½çš„è§£é‡Šã€‚åŸºæœ¬è¦ç‚¹æ˜¯ï¼Œæˆ‘ä»¬æ­£åœ¨å¯»æ‰¾è®¡ç®—å¦‚ä¸‹çš„`terminal_states`:](https://chance.dartmouth.edu/teaching_aids/books_articles/probability_book/amsbook.mac.pdf)

`B = N*R = (I-Q)^(-1) * R`

è®²åº§è§£é‡Šäº†æˆ‘ä»¬å¦‚ä½•å¾—åˆ°`Q`å’Œ`R`ï¼Œä½†æœ¬è´¨ä¸Šï¼Œå®ƒä»¬åªæ˜¯ç»è¿‡ä¸€äº›æ’åºå’Œè§„èŒƒåŒ–åçš„çŸ©é˜µçš„ä¸€éƒ¨åˆ†ã€‚é‡æ–°å®ç°åæ¼”æ‰€éœ€çš„é«˜æ–¯æ¶ˆå»æ³•æœ‰ç‚¹ä¹å‘³ï¼Œä½†ä¸€æ—¦ç†è§£äº†ç†è®ºåŸºç¡€ï¼Œå®ƒæœ€ç»ˆä¼šå˜å¾—éå¸¸ç®€å•ã€‚

æ‚¨å¯ä»¥åœ¨æ­¤æ‰¾åˆ°å®Œæ•´çš„é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ[ã€‚](https://github.com/FBosler/GoogleFoobar/tree/main/problem_3/a)

## é—®é¢˜ 3bã€‚

è¯¥é—®é¢˜æ˜¯ä¸€ä¸ªæœ€çŸ­è·¯å¾„é—®é¢˜ï¼Œé™„åŠ æ¡ä»¶æ˜¯å¯ä»¥å¿½ç•¥ä¸€ä¸ªéšœç¢ã€‚åƒè¿™æ ·çš„é—®é¢˜å¾ˆå®¹æ˜“è½¬åŒ–ä¸ºç°å®ç”Ÿæ´»ä¸­çš„åº”ç”¨ç¨‹åºï¼Œæ¯”å¦‚æ‰¾åˆ°ä»ä¸€ä¸ªåŸå¸‚åˆ°å¦ä¸€ä¸ªåŸå¸‚çš„æœ€çŸ­è·¯çº¿ï¼Œåªéœ€æ”¯ä»˜ä¸€å®šæ•°é‡çš„é«˜é€Ÿå…¬è·¯é€šè¡Œè´¹ã€‚æˆ–è€…æœ€å¤šè·¯è¿‡ä¸€å®¶éº¦å½“åŠ³ï¼Œå› ä¸ºä¸æƒ³è®©å­©å­å¤ªéš¾è¿‡:)

```
**Problem:**...Unfortunately (again), you can't just remove all obstacles between the bunnies and the escape pods - 
at most you can remove one wall per escape pod path, both to maintain structural integrity of the station and 
to avoid arousing Commander Lambda's suspicions.

You have maps of parts of the space station, each starting at a prison exit and ending at the door to an escape pod. 
The map is represented as a matrix of 0s and 1s, where 0s are passable space and 1s are impassable walls. 
The door out of the prison is at the top left (0,0) and the door into an escape pod is at the bottom right (w-1,h-1).

Write a function solution(map) that generates the length of the shortest path from the prison door to the escape pod, 
where you are allowed to remove one wall as part of your remodeling plans. The path length is the total number of nodes
you pass through, counting both the entrance and exit nodes. The starting and ending positions are always passable (0).
The map will always be solvable, though you may or may not need to remove a wall. 
The height and width of the map can be from 2 to 20\. Moves can only be made in cardinal directions; 
no diagonal moves are allowed.
```

ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘åœ¨æˆ‘æ‰€è°“çš„`double layered graph`ä¸Šä½¿ç”¨äº†å¹¿åº¦ä¼˜å…ˆæœç´¢ã€‚æˆ‘ç¡®ä¿¡æˆ‘æ²¡æœ‰å‘æ˜å®ƒï¼Œåªæ˜¯åœ¨æŸå¤„è¯»åˆ°è¿‡ï¼Œä½†æ˜¯æœ€ç»ˆçš„å®ç°æ„Ÿè§‰çœŸçš„å¾ˆå¥½ã€‚å°¤å…¶æ˜¯åœ¨æœ€åˆå°è¯•äº†è›®åŠ›æ–¹æ³•ä¹‹åã€‚

æˆ‘æ€è€ƒè¿™ä¸ªé—®é¢˜çš„æ–¹å¼æ˜¯åˆ›å»ºä¸¤ä¸ªç›¸åŒçš„è¿·å®«å±‚ï¼Œå¹¶å°†å®ƒä»¬å æ”¾åœ¨ä¸€èµ·ã€‚åœ¨è¿·å®«ä¸­ç©¿è¡Œæ—¶ï¼Œæˆ‘ä»¬å‘ç°ç›¸é‚»çš„èŠ‚ç‚¹ï¼Œå¹¶å°†å®ƒä»¬æ”¾å…¥ä¸€ä¸ªåŒç«¯é˜Ÿåˆ—ä¸­ã€‚ç„¶åï¼Œæˆ‘ä»¬é€ä¸ªåˆ é™¤(`visit them`)é˜Ÿåˆ—ä¸­çš„èŠ‚ç‚¹ï¼Œå¹¶å‘ç°æ–°èŠ‚ç‚¹ã€‚åœ¨åŸºç¡€å±‚ä¸­ï¼Œå¢™å¯ä»¥è¢«å‘ç°ä¸ºå¯è®¿é—®çš„èŠ‚ç‚¹ã€‚ä½†æ˜¯ï¼Œé˜´å½±å±‚ä¸­çš„å¢™ä¸èƒ½è¢«å‘ç°(å³ï¼Œå®ƒä»¬ä¸èƒ½è¢«ç©¿è¿‡)ã€‚

å½“è®¿é—®åŸºç¡€å±‚ä¸­çš„èŠ‚ç‚¹æ—¶ï¼Œæˆ‘ä»¬å°†åŸºç¡€å±‚ä¸­çš„èŠ‚ç‚¹å’Œé˜´å½±å±‚ä¸­çš„å¯¹åº”èŠ‚ç‚¹æ ‡è®°ä¸ºå·²è®¿é—®ã€‚æˆ‘ä»¬è¿™æ ·åšæ˜¯å› ä¸ºå‘ç°ä¸€ä¸ªèŠ‚ç‚¹è€Œä¸å…ˆç¢°å£ç»å¯¹æ›´å¥½ã€‚ä¸€æ—¦æˆ‘ä»¬è¸å…¥ä¸€é¢å¢™ï¼Œæˆ‘ä»¬å°±è½¬æ¢åˆ°é˜´å½±å±‚ï¼Œä»è€Œç¡®ä¿è¿™ç§ç‰¹æ®Šçš„éå†ä¸ä¼šç¢°åˆ°å¦ä¸€é¢å¢™ã€‚

ä½ å¯ä»¥åœ¨è¿™é‡Œæ‰¾åˆ°å®Œæ•´çš„é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ[ã€‚](https://github.com/FBosler/GoogleFoobar/tree/main/problem_3/b)

## é—®é¢˜ 3cã€‚

è¿™ä¸ªé—®é¢˜æ¯” 3a ç®€å•å¤šäº†ã€‚å’Œ 3bã€‚ä¸€æ—¦æˆ‘ä»¬è€ƒè™‘äºŒè¿›åˆ¶è¡¨ç¤ºï¼Œè¿™ä¸ªæœ‰è¶£çš„é—®é¢˜å°±å˜å¾—å®¹æ˜“è§£å†³äº†ã€‚

```
**Problem:****...**The fuel control mechanisms have three operations: 

1) Add one fuel pellet
2) Remove one fuel pellet
3) Divide the entire group of fuel pellets by 2 (due to the destructive energy released when a quantum antimatter 
pellet is cut in half, the safety controls will only allow this to happen if there is an even number of pellets)

Write a function called solution(n) which takes a positive integer as a string and returns the minimum number of 
operations needed to transform the number of pellets to 1\. The fuel intake control panel can only display a 
number up to 309 digits long, so there won't ever be more pellets than you can express in that many digits.
```

å“‡ï¼Œä¸€ä¸ª 309 ä½æ•°çš„æ•°å­—å¤ªå¤§äº†ã€‚å¤§çº¦æ˜¯ 2 çš„ 1026 æ¬¡æ–¹ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬çœŸçš„è¿›å…¥äº†`OverflowError`é¢†åŸŸï¼Œåªæ˜¯å¤©çœŸåœ°åº”ç”¨è¯•é”™æ³•ä¼šå¯¼è‡´ä¸€ä¸ªéå¸¸ä½æ•ˆçš„ç®—æ³•ã€‚

ç„¶è€Œï¼Œä¸€æ—¦æˆ‘ä»¬ç†è§£äº†é€šè¿‡å°†`n`è½¬æ¢ä¸ºäºŒè¿›åˆ¶å¹¶æŸ¥çœ‹å°¾éš 0 çš„æ•°é‡ï¼Œæˆ‘ä»¬å°±å·²ç»çŸ¥é“æˆ‘ä»¬å¯ä»¥è¢« 2 é™¤å¤šå°‘æ¬¡ã€‚ç§»é™¤è¿™äº›é›¶ç›¸å½“äºé™¤ä»¥ 2 çš„é›¶çš„å¹‚ã€‚å¦‚æœæ²¡æœ‰å°¾éšé›¶ï¼Œæˆ‘ä»¬æ£€æŸ¥ä¸‹ä¸€ä¸ªå¾ªç¯ï¼Œæ·»åŠ æˆ–åˆ é™¤ä¸€ä¸ªæ˜¯å¦ä¼šå¯¼è‡´æ›´å¤šå°¾éšé›¶(å³ï¼Œæ›´å°‘çš„æ“ä½œ)ã€‚

æ‚¨å¯ä»¥åœ¨æ­¤å¤„æ‰¾åˆ°å®Œæ•´çš„é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ[ã€‚](https://github.com/FBosler/GoogleFoobar/tree/main/problem_3/c)

![](img/aef1166ed27ed4f3f9a191a1254030c9.png)

ç¬¬ 3 çº§åçš„æ‹›è˜äººå‘˜æ”¿ç­–

## é—®é¢˜ 4aã€‚

å¦‚æœæˆ‘æ²¡è®°é”™çš„è¯ï¼Œè¿™æ˜¯æˆ‘èŠ±äº†æœ€å¤šæ—¶é—´çš„é—®é¢˜ã€‚è¿™ä¸ªé—®é¢˜å½’ç»“ä¸ºåœ¨å›¾ä¸Šå¯»æ‰¾æœ€å¤§åŒ¹é…ã€‚æˆ‘æœ€å¼€å§‹æƒ³ç”¨çš„ç®—æ³•æ˜¯ [Blossom ç®—æ³•](https://stanford.edu/~rezab/classes/cme323/S16/projects_reports/shoemaker_vare.pdf)ã€‚ç„¶è€Œï¼ŒBlossom çš„å¤æ‚åº¦ä¸º`O(|E||V|^2)`ï¼ŒBlossom ç®—æ³•æœ‰ä¸€ä¸ªå˜ç§ï¼Œå¤æ‚åº¦ä¸º`O(|E||V|^(1/2))`ã€‚å¸Œå°”ç»´å¥¥Â·ç±³å¡åˆ©å’Œç»´è´¾ä¼ŠÂ·ç“¦é½æ‹‰å°¼å¼€å‘äº†è¿™ä¸ªç®—æ³•ã€‚è¿™é‡Œå¯ä»¥æ‰¾åˆ°ä¸€ä¸ªè¯æ˜ã€‚

æˆ‘ç¨å¾®ç ”ç©¶äº†ä¸€ä¸‹è¿™ä¸ªç®—æ³•ï¼Œç”šè‡³çœ‹äº† YouTube ä¸Šå…³äºå®ƒçš„è®¨è®ºï¼Œä½†æ˜¯æˆ‘è§‰å¾—æˆ‘å¹¶æ²¡æœ‰çœŸæ­£ç†è§£è¿™ä¸ªç®—æ³•ï¼Œæ‰€ä»¥æˆ‘å†³å®šä¸ä½¿ç”¨å®ƒã€‚æœ€ç»ˆï¼Œæˆ‘ä½¿ç”¨æ·±åº¦ä¼˜å…ˆæœç´¢æ¥æœç´¢å¤æ‚åº¦ä¸º T5 çš„ T4ã€‚

```
**Problem:**...You will set up simultaneous thumb wrestling matches. In each match, two guards will pair off to thumb wrestle. The guard with fewer bananas will bet all their bananas, and the other guard will match the bet. The winner will receive all of the bet bananas. You don't pair off guards with the same number of bananas (you will see why, shortly). You know enough guard psychology to know that the one who has more bananas always gets over-confident and loses. Once a match begins, the pair of guards will continue to thumb wrestle and exchange bananas, until both of them have the same number of bananas. Once that happens, both of them will lose interest and go back to guarding the prisoners, and you don't want THAT to happen!

For example, if the two guards that were paired started with 3 and 5 bananas, after the first round of thumb wrestling they will have 6 and 2 (the one with 3 bananas wins and gets 3 bananas from the loser). After the second round, they will have 4 and 4 (the one with 6 bananas loses 2 bananas). At that point they stop and get back to guarding.

How is all this useful to distract the guards? Notice that if the guards had started with 1 and 4 bananas, then they keep thumb wrestling! 1, 4 -> 2, 3 -> 4, 1 -> 3, 2 -> 1, 4 and so on.

Now your plan is clear. You must pair up the guards in such a way that the maximum number of guards go into an infinite thumb wrestling loop!Write a function solution(banana_list) which, given a list of positive integers depicting the amount of bananas the each guard starts with, returns the fewest possible number of guards that will be left to watch the prisoners. Element i of the list will be the number of bananas that guard i (counting from 0) starts with.

The number of guards will be at least 1 and not more than 100, and the number of bananas each guard starts with will be a positive integer no more than 1073741823 (i.e. 2^30 -1). Some of them stockpile a LOT of bananas.
```

ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬é¦–å…ˆæ„å»ºä¸€ä¸ªå›¾ï¼Œå…¶ä¸­æ¯æ¡è¾¹è¡¨ç¤ºä¸¤ä¸ªå®ˆå«ä¹‹é—´çš„æ­»é”ã€‚æˆ‘ä»¬å°†è¯¥ä¿¡æ¯å­˜å‚¨åœ¨ä¸€ä¸ªçŸ©é˜µä¸­ï¼Œå…¶ä¸­ä½ç½®`(i,j)`å¤„çš„ 1 è¡¨ç¤ºä¿æŠ¤`i`å’Œä¿æŠ¤`j`ä¹‹é—´çš„æ­»é”ã€‚0 è¡¨ç¤ºç»ˆæ­¢åŒ¹é…ã€‚

æˆ‘ä»¬å°†åˆ©ç”¨[å¢åŠ è·¯å¾„](https://www.baeldung.com/cs/augmenting-path)çš„æ¦‚å¿µæ¥å¯»æ‰¾æœ€ä¼˜è§£ã€‚å½“æˆ‘ä»¬æ‰¾åˆ°ä¸€æ¡å¢åŠ çš„è·¯å¾„(å¹¶ä¸”å‰©ä¸‹ä¸åŒ¹é…çš„é¡¶ç‚¹)æ—¶ï¼Œæˆ‘ä»¬å°†é‡å¤ä»¥ä¸‹æ­¥éª¤:

1.  å°†è®¿é—®è¿‡çš„æ•°ç»„å’Œè·¯å¾„è®¾ç½®ä¸ºç©ºæ•°ç»„
2.  å½“å‰é¡¶ç‚¹ä»æˆ‘ä»¬çš„ä¸åŒ¹é…é¡¶ç‚¹åˆ—è¡¨ä¸­å¼¹å‡º
3.  æ£€æŸ¥æˆ‘ä»¬æ˜¯å¦èƒ½æ‰¾åˆ°ç”µæµå¢åŠ è·¯å¾„çš„äº¤æ›¿å»¶ä¼¸
4.  å¦‚æœæˆ‘ä»¬å‘ç°ä¸€ä¸ªäº¤æ›¿æ‰©å±•ï¼Œæˆ‘ä»¬å°†å½“å‰é¡¶ç‚¹æ·»åŠ åˆ°è·¯å¾„ä¸­ï¼Œå¹¶ç§»åŠ¨åˆ°é‚»å±…
5.  å¦‚æœæˆ‘ä»¬æ²¡æœ‰æ‰¾åˆ°äº¤æ›¿çš„æ‰©å±•ï¼Œæˆ‘ä»¬å›æº¯
6.  ç°åœ¨ï¼Œå¦‚æœå½“å‰é¡¶ç‚¹(æˆ–è€…æ˜¯é‚»å±…æˆ–è€…æ˜¯å‰ä¸€ä¸ªé¡¶ç‚¹)åœ¨ä¸åŒ¹é…é¡¶ç‚¹åˆ—è¡¨ä¸­ï¼Œæˆ‘ä»¬å°†æŠŠè¿™ä¸ªé¡¶ç‚¹æ·»åŠ åˆ°æˆ‘ä»¬çš„è·¯å¾„ä¸­ï¼Œå¹¶æ›´æ–°æˆ‘ä»¬çš„åŒ¹é…å’Œä¸åŒ¹é…è¾¹åˆ—è¡¨

ä¸€æ—¦æˆ‘ä»¬æ‰¾ä¸åˆ°å¢åŠ çš„è·¯å¾„ï¼Œæˆ‘ä»¬å°±ä¸­æ–­å¾ªç¯ã€‚é€šè¿‡ä»å®ˆå«æ•°é‡ä¸­å‡å»åŒ¹é…çš„æ•°é‡ï¼Œæˆ‘ä»¬è·å¾—ä¸åŒ¹é…çš„å®ˆå«æ•°é‡ã€‚

ä½ å¯ä»¥åœ¨è¿™é‡Œæ‰¾åˆ°å®Œæ•´çš„é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ[ã€‚](https://github.com/FBosler/GoogleFoobar/tree/main/problem_4/a)

## **é—®é¢˜ 4bã€‚**

å››çº§ç¬¬äºŒé¢˜æˆ‘éƒ½å¿«ä¸è®°å¾—äº†ã€‚

```
**Problem:**You need to free the bunny prisoners before Commander Lambda's space station explodes! Unfortunately, the commander was
very careful with her highest-value prisoners - they're all held in separate, maximum-security cells.
The cells are opened by putting keys into each console, then pressing the open button on each console simultaneously.
When the open button is pressed, each key opens its corresponding lock on the cell. So, the union of the keys in all of
the consoles must be all of the keys. The scheme may require multiple copies of one key given to different minions.

The consoles are far enough apart that a separate minion is needed for each one. Fortunately, you have already freed
some bunnies to aid you - and even better, you were able to steal the keys while you were working as
Commander Lambda's assistant. The problem is, you don't know which keys to use at which consoles. The consoles are
programmed to know which keys each minion had, to prevent someone from just stealing all of the keys and using them
blindly. There are signs by the consoles saying how many minions had some keys for the set of consoles.
You suspect that Commander Lambda has a systematic way to decide which keys to give to each minion such that they
could use the consoles.

You need to figure out the scheme that Commander Lambda used to distribute the keys. You know how many minions had keys,
and how many consoles are by each cell. You know that Command Lambda wouldn't issue more keys than necessary
(beyond what the key distribution scheme requires), and that you need as many bunnies with keys as there are consoles
to open the cell.

Given the number of bunnies available and the number of locks required to open a cell, write a function
solution(num_buns, num_required) which returns a specification of how to distribute the keys such that any num_required
bunnies can open the locks, but no group of (num_required - 1) bunnies can.

Each lock is numbered starting from 0\. The keys are numbered the same as the lock they open (so for a duplicate key,
the number will repeat, since it opens the same lock). For a given bunny, the keys they get is represented as a
sorted list of the numbers for the keys. To cover all of the bunnies, the final answer is represented by a sorted
list of each individual bunny's list of keys.  Find the lexicographically least such key distribution - that is,
the first bunny should have keys sequentially starting from 0.
```

æˆ‘è®°å¾—çš„ä¸€ä»¶äº‹æ˜¯ï¼Œæˆ‘çœ‹çš„æ—¶å€™å‘ç°è¿™ä¸ªé—®é¢˜å¾ˆæ··ä¹±ã€‚æˆ‘èŠ±äº†ä¸€äº›æ—¶é—´æ‰çœŸæ­£ç†è§£æˆ‘ä»¬åº”è¯¥å‘ç°ä»€ä¹ˆã€‚ç„¶è€Œï¼Œä¸€æ—¦é—®é¢˜é™ˆè¿°æ¸…æ¥šäº†ï¼Œè§£å†³æ–¹æ¡ˆå°±æ˜¯ä¸€ä¸ªç®€å•çš„ç»„åˆå­¦åº”ç”¨(æ›´å‡†ç¡®åœ°è¯´æ˜¯ç»„åˆ)ã€‚

```
from itertools import combinations**def solution(num_buns, num_required):** *"""
Number of copies per key:
-------------------------
Select any group of "num_required - 1" bunnies. By specification they can not open the door.
However, if we were to add any one of the remaining "num_buns - (num_required - 1)" bunnies,
we would be able to open the door.

=> every one of the remaining "num_buns - num_required + 1" bunnies has exactly one key that
   is not in the union of keys of the selected "num_required - 1".

This means that every key has exactly
num_buns - num_required + 1
copies (called copies_per_key)

Total keys:
-----------
Based on the above logic, there are exactly
/      num_buns    \
\ num_required - 1 /
different sets of bunnies that miss one key to being able to open the door.

=> there is a total number of distinct keys =
/      num_buns    \
\ num_required - 1 /
=
/            num_buns         \
\ num_buns - num_required + 1 /
= len(combinations(range(num_buns), copies_per_key))
"""*key_sets = [[] for _ in range(num_buns)]

copies_per_key = num_buns - num_required + 1

for key, bunnies in enumerate(combinations(range(num_buns), copies_per_key)):
    for bunny in bunnies:
        key_sets[bunny].append(key)

return key_sets
```

ä½ å¯ä»¥åœ¨è¿™é‡Œæ‰¾åˆ°å®Œæ•´çš„é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ[ã€‚](https://github.com/FBosler/GoogleFoobar/tree/main/problem_4/b)

## **é—®é¢˜ 5ã€‚**

è¿™ä¸ªé—®é¢˜æ¥è‡ªç¾¤è®ºé¢†åŸŸï¼Œæˆ‘åœ¨å¤§å­¦æœŸé—´éå¸¸å–œæ¬¢è¿™ä¸ªé¢†åŸŸã€‚ç„¶è€Œï¼Œåœ¨é˜…è¯»ã€ŠåŸºç¡€ã€‹æ—¶ï¼Œæˆ‘ä¹Ÿå‘ç°äº† Foobar é—®é¢˜çš„è§£å†³æ–¹æ¡ˆã€‚[è§£å†³æ–¹æ¡ˆ](https://github.com/franklinvp/foobar/blob/master/foobar2020/solutionProblem1.py)å’Œ[å¯¹åº”çš„åšå®¢å¸–å­](https://franklinvp.github.io/2020-06-05-PolyaFooBar/)ç›¸å½“ç²¾å½©ï¼Œæ‰€ä»¥æˆ‘ç›´æ¥å¤åˆ¶äº†è§£å†³æ–¹æ¡ˆå¹¶å¼•ç”¨äº†åŸä½œè€…ï¼Œå› ä¸ºæˆ‘è§‰å¾—æˆ‘æ— è®ºå¦‚ä½•ä¹Ÿæ— æ³•æ”¹è¿›ç®—æ³•ã€‚

```
**Problem:**... There's something important to note about quasar quantum flux fields' configurations: when drawn on a star grid, configurations are considered equivalent by grouping rather than by order. That is, for a given set of configurations, if you exchange the position of any two columns or any two rows some number of times, youll find that all of those configurations are equivalent in that way - in grouping, rather than order.

Write a function solution(w, h, s) that takes 3 integers and returns the number of unique, non-equivalent configurations that can be found on a star grid w blocks wide and h blocks tall where each celestial body has s possible states. Equivalency is defined as above: any two star grids with each celestial body in the same state where the actual order of the rows and columns do not matter (and can thus be freely swapped around). Star grid standardization means that the width and height of the grid will always be between 1 and 12, inclusive. And while there are a variety of celestial bodies in each grid, the number of states of those bodies is between 2 and 20, inclusive. The solution can be over 20 digits long, so return it as a decimal string.  The intermediate values can also be large, so you will likely need to use at least 64-bit integers.
```

ä½ å¯ä»¥åœ¨è¿™é‡Œæ‰¾åˆ°å®Œæ•´çš„é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ[ã€‚](https://github.com/FBosler/GoogleFoobar/tree/main/problem_5)

# é‚£ä¹ˆæˆ‘æäº¤äº† Google çš„ Foobar ä¹‹åå‘ç”Ÿäº†ä»€ä¹ˆï¼Ÿ

ç´§æ¥ç€çº§åˆ« 5ï¼Œæ˜¾ç¤ºäº† base64 ç¼–ç çš„å­—ç¬¦ä¸²ã€‚å¯¹è¿™ä¸ªå­—ç¬¦ä¸²è¿›è¡Œè§£ç ï¼Œç„¶åå¯¹æˆ‘çš„ä¸ªäººç”¨æˆ·åè¿›è¡ŒæŒ‰ä½å¼‚æˆ–è¿ç®—ï¼Œç„¶åå°†ç»“æœè½¬æ¢å› Unicodeï¼Œå¾—åˆ°æˆ‘è®¤ä¸ºæ˜¯æŸç§å½¢å¼çš„æœ€ç»ˆåˆ†æ•°ã€‚

![](img/8bebece0a189ed4f7b2e982ce240b6dd.png)

æ¥è‡ª Foobar çš„æœ€ç»ˆè§£å¯†ä¿¡æ¯

å—¯ï¼Œè¿™æœ‰ç‚¹ä»¤äººå¤±æœ›ã€‚ä½†æ˜¯åæ¥ä»€ä¹ˆéƒ½æ²¡å‘ç”Ÿã€‚æ®æˆ‘æ‰€çŸ¥ï¼Œæœ‰æ—¶æ‹›è˜äººå‘˜ä¼šä¸»åŠ¨è”ç³»è¢«é‚€è¯·åˆ° Foobar çš„å¼€å‘äººå‘˜ã€‚è¿™é‡Œæ²¡æœ‰å‘ç”Ÿè¿™ç§æƒ…å†µã€‚æˆ‘å¾ˆå¥½å¥‡æ¥ä¸‹æ¥ä¼šå‘ç”Ÿä»€ä¹ˆã€‚

ä¹Ÿè®¸æˆ‘ä¸åº”è¯¥åœ¨æœ€åä¸€ä¸ªé—®é¢˜ä¸Šä½œå¼ŠğŸ˜‚ã€‚

ä¹Ÿå¯èƒ½æ˜¯å› ä¸ºæˆ‘çš„ä»£ç æ²¡æœ‰é€šè¿‡ä¸€äº›å†…éƒ¨æµ‹è¯•ï¼Œæˆ–è€…æ˜¯å› ä¸ºæˆ‘çš„ç®€å†ä¸ç¬¦åˆå…¸å‹çš„è°·æ­Œç”³è¯·äººã€‚ä¸ç®¡æ€æ ·ï¼Œæˆ‘ä»æŒ‘æˆ˜ä¸­è·å¾—äº†æ— ç©·çš„ä¹è¶£ï¼Œå¹¶ä¸”åˆšåˆšæ„è¯†åˆ° Foobar æœåŠ¡å™¨ä¸­æœ‰æ–°çš„é—®é¢˜ã€‚æˆ‘çš„ç™»å½•ä»ç„¶æœ‰æ•ˆï¼Œæ‰€ä»¥æˆ‘è¦è§£å†³æ›´å¤šçš„é—®é¢˜ï¼æ•¬è¯·å…³æ³¨æ›´å¤šå†…å®¹ã€‚

![](img/9f7982ea0a66355456cece53c1aa18ba.png)

æˆ‘åˆšåˆšæå‡ºäº†ä¸€ä¸ªæ–°é—®é¢˜ã€‚æ—¶é’Ÿåˆå¼€å§‹æ»´ç­”ä½œå“äº†ã€‚

**æ›´æ–°:**è§£å†³äº†æ–°é—®é¢˜ã€‚æˆ‘ä¹Ÿå¾ˆå–œæ¬¢é‚£ä¸ªã€‚æŸ¥çœ‹ç›¸åº”çš„æ–‡ç« :

[](https://towardsdatascience.com/dodge-the-lasers-fantastic-question-from-googles-hiring-challenge-72363d95fec) [## é¿å¼€æ¿€å…‰â€”â€”æ¥è‡ªè°·æ­Œæ‹›è˜æŒ‘æˆ˜çš„å¥‡å¦™é—®é¢˜

### è°·æ­Œæœ‰ä¸€ä¸ªåä¸º Foobar çš„ç§˜å¯†æ‹›è˜æŒ‘æˆ˜ã€‚æˆ‘å–œæ¬¢è¿™äº›é—®é¢˜ï¼Œå› ä¸ºå®ƒä»¬è®©æˆ‘å†æ¬¡ä½¿ç”¨æ•°å­¦ã€‚

towardsdatascience.com](https://towardsdatascience.com/dodge-the-lasers-fantastic-question-from-googles-hiring-challenge-72363d95fec)